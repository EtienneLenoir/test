super, j’ai bien compris : tu veux historiser les jours de retard (Insuffisance < 0) par clé Booking + NO DOSSIER CREDIT, avec :

une table “flux” (les retards en cours) contenant nb de jours, date début, pire insuffisance et sa date, la dernière date traitée, etc.

une table “archive” (épisodes clos) avec date début, date fin, nb total de jours, pire insuffisance et sa date.

un bouton dans Excel que tu cliques chaque jour pour ingérer le fichier du jour, mettre à jour flux & archive, puis ajouter 2 colonnes sur la feuille (“NB Jours de retard”, “Date de début de retard”).

Ci-dessous je te donne une architecture propre + un module VBA complet qui :

crée (si besoin) l’Access .accdb, les tables et index,

lit ta feuille du jour,

met à jour la table Flux_Retard et Archive_Retard,

retire du flux ce qui n’est plus en retard (en archivant avec date_fin = ProductionDate – 1),

écrit sur la feuille les colonnes demandées.

1) Schéma Access (simple, rapide, maintenable)

Nom du fichier (par défaut) : .\data\Lombard_Retards.accdb (dossier créé automatiquement à côté de ton Excel).

Table Flux_Retard (retards en cours)

booking (TEXT, 20) — indexé

no_dossier_credit (TEXT, 40) — indexé

date_debut (DATE) — début de l’épisode

nb_jours (LONG) — compteur de jours de retard

pire_insuffisance (DOUBLE) — la valeur la plus négative observée

date_pire_insuffisance (DATE)

insuffisance_du_jour (DOUBLE)

last_production_date (DATE)

PK composite: (booking,no_dossier_credit)
Index utiles: (booking), (no_dossier_credit).

Table Archive_Retard (épisodes clos)

booking (TEXT, 20)

no_dossier_credit (TEXT, 40)

date_debut (DATE)

date_fin (DATE) — ProductionDate – 1 du jour de résolution

nb_jours_total (LONG)

pire_insuffisance (DOUBLE)

date_pire_insuffisance (DATE)

Index: (booking), (no_dossier_credit), (date_fin).

Remarque : je garde le schéma minimal pour la vitesse, mais tu peux ajouter d’autres champs “dernière vue” (taux de couverture, limites, etc.) si tu veux les exploiter dans des rapports.

2) Hypothèses de mapping depuis Excel

Tes entêtes exactes (respectées, insensibles à la casse, accents acceptés) :

Booking

Production Date

NO DOSSIER CREDIT

NO NTERVENANT

NO NTERVENANT GRP

Ligne

Limite

Consommation

Montant Surete

Montant AM

Insuffisance

Taux de couverture

Clé unique = Booking + NO DOSSIER CREDIT.
Retard du jour si Insuffisance < 0.

3) Ce que fait le bouton (logique métier)

Pour la ProductionDate du jour (prise comme le max de ta colonne “Production Date” si plusieurs valeurs) :

Pour chaque ligne Insuffisance < 0 :

Si la clé n’existe pas en Flux_Retard → insert avec
date_debut = ProductionDate, nb_jours = 1,
pire_insuffisance = Insuffisance, date_pire_insuffisance = ProductionDate,
insuffisance_du_jour = Insuffisance, last_production_date = ProductionDate.

Si la clé existe → update
nb_jours += DateDiff("d", last_production_date, ProductionDate) (robuste si on a sauté des jours),
insuffisance_du_jour = Insuffisance,
si Insuffisance < pire_insuffisance (plus négatif) alors on met à jour pire_insuffisance + sa date,
et on met last_production_date = ProductionDate.

Pour chaque clé présente dans Flux_Retard absente des retards du jour (ou avec Insuffisance >= 0) :
→ archiver : insert en Archive_Retard avec
date_fin = ProductionDate - 1, nb_jours_total = nb_jours, etc., puis delete de Flux_Retard.

À la fin, on écrit 2 colonnes dans ta feuille du jour :
NB Jours de retard, Date de début de retard (basées sur Flux_Retard, sinon 0/blank).

4) Module VBA (copie/colle tel quel)

Pré-requis :

Activer la référence Microsoft DAO x.x Object Library (VBE > Tools > References).

Optionnel mais conseillé : Microsoft Scripting Runtime (pour Dictionary).

Crée un module standard LombardRetard.bas et colle :

Option Explicit

' ====== PARAMÈTRES ======
Private Const DB_FOLDER As String = "data"
Private Const DB_NAME As String = "Lombard_Retards.accdb"

' ====== BOUTON PRINCIPAL ======
Public Sub RunDailyUpdate()
    On Error GoTo EH

    Dim ws As Worksheet
    Set ws = ActiveSheet   ' ta feuille du jour, cliquer le bouton depuis cette feuille

    Dim dbPath As String
    dbPath = EnsureDatabase()

    Dim prodDate As Date
    prodDate = DetectProductionDate(ws)

    Dim overdue As Object ' Scripting.Dictionary : key -> rowInfo
    Set overdue = BuildTodayOverdue(ws)

    Dim db As DAO.Database
    Set db = DAO.DBEngine.OpenDatabase(dbPath)

    EnsureTables db

    ' Charger le flux existant en mémoire pour performance
    Dim flux As Object: Set flux = LoadFluxIntoDict(db)

    ' Upsert des retards du jour
    UpsertTodayOverdue db, flux, overdue, prodDate

    ' Archiver ce qui sort du flux
    CloseResolvedToArchive db, flux, overdue, prodDate

    ' Écrire les colonnes sur la feuille
    WriteSheetCounters ws, db, overdue

    db.Close
    Set db = Nothing

    MsgBox "Mise à jour terminée." & vbCrLf & "ProductionDate = " & Format(prodDate, "yyyy-mm-dd"), vbInformation
    Exit Sub

EH:
    MsgBox "Erreur: " & Err.Number & " - " & Err.Description, vbCritical
End Sub

' ====== DÉTECTION DE LA PRODUCTION DATE ======
Private Function DetectProductionDate(ws As Worksheet) As Date
    Dim colPD As Long: colPD = FindColumn(ws, "Production Date")
    If colPD = 0 Then Err.Raise 5, , "Colonne 'Production Date' introuvable."
    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, colPD).End(xlUp).Row

    Dim r As Long, d As Date, maxD As Date
    For r = 2 To lastRow
        If Not IsEmpty(ws.Cells(r, colPD).Value) Then
            d = CDate(ws.Cells(r, colPD).Value)
            If d > maxD Then maxD = d
        End If
    Next
    If maxD = 0 Then Err.Raise 5, , "Aucune date trouvée dans 'Production Date'."
    DetectProductionDate = maxD
End Function

' ====== CONSTRUIRE LE SET DES RETARDS DU JOUR ======
Private Function BuildTodayOverdue(ws As Worksheet) As Object
    Dim colB As Long, colDossier As Long, colIns As Long, colPD As Long
    colB = FindColumn(ws, "Booking")
    colDossier = FindColumn(ws, "NO DOSSIER CREDIT")
    colIns = FindColumn(ws, "Insuffisance")
    colPD = FindColumn(ws, "Production Date")

    If colB = 0 Or colDossier = 0 Or colIns = 0 Or colPD = 0 Then
        Err.Raise 5, , "Colonnes clés manquantes (Booking/NO DOSSIER CREDIT/Insuffisance/Production Date)."
    End If

    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, colB).End(xlUp).Row

    Dim d As Object: Set d = CreateObject("Scripting.Dictionary")
    Dim r As Long, key As String, insuff As Double, pd As Date

    For r = 2 To lastRow
        If Not IsEmpty(ws.Cells(r, colB)) And Not IsEmpty(ws.Cells(r, colDossier)) Then
            key = MakeKey(Trim$(CStr(ws.Cells(r, colB).Value)), Trim$(CStr(ws.Cells(r, colDossier).Value)))
            If Not IsEmpty(ws.Cells(r, colIns).Value) Then
                insuff = CDbl(ws.Cells(r, colIns).Value)
                If insuff < 0 Then
                    pd = CDate(ws.Cells(r, colPD).Value)
                    ' On garde la dernière ligne pour la clé si doublons : la plus récente
                    Dim info As Variant
                    info = Array(ws.Cells(r, colB).Value, ws.Cells(r, colDossier).Value, pd, insuff)
                    d(key) = info
                End If
            End If
        End If
    Next

    Set BuildTodayOverdue = d
End Function

Private Function MakeKey(booking As String, dossier As String) As String
    MakeKey = UCase$(booking) & "||" & UCase$(dossier)
End Function

Private Function FindColumn(ws As Worksheet, headerName As String) As Long
    Dim c As Range
    For Each c In ws.Rows(1).Cells
        If Trim$(UCase$(CStr(c.Value))) = Trim$(UCase$(headerName)) Then
            FindColumn = c.Column
            Exit Function
        End If
    Next
    FindColumn = 0
End Function

' ====== ACCESS : CRÉATION DB & TABLES ======
Private Function EnsureDatabase() As String
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    Dim folderPath As String
    folderPath = ThisWorkbook.Path & Application.PathSeparator & DB_FOLDER
    If Not fso.FolderExists(folderPath) Then fso.CreateFolder folderPath

    Dim dbPath As String
    dbPath = folderPath & Application.PathSeparator & DB_NAME

    If Not fso.FileExists(dbPath) Then
        Dim ws As Workspace
        Set ws = DBEngine.Workspaces(0)
        Dim newDb As DAO.Database
        Set newDb = ws.CreateDatabase(dbPath, dbLangGeneral, dbVersion120)
        newDb.Close
        Set newDb = Nothing
    End If
    EnsureDatabase = dbPath
End Function

Private Sub EnsureTables(db As DAO.Database)
    On Error Resume Next
    db.Execute "CREATE TABLE Flux_Retard (" & _
               "booking TEXT(20) NOT NULL, " & _
               "no_dossier_credit TEXT(40) NOT NULL, " & _
               "date_debut DATETIME, " & _
               "nb_jours LONG, " & _
               "pire_insuffisance DOUBLE, " & _
               "date_pire_insuffisance DATETIME, " & _
               "insuffisance_du_jour DOUBLE, " & _
               "last_production_date DATETIME, " & _
               "CONSTRAINT pk_flux PRIMARY KEY (booking, no_dossier_credit))", dbFailOnError
    db.Execute "CREATE INDEX idx_flux_booking ON Flux_Retard(booking)"
    db.Execute "CREATE INDEX idx_flux_dossier ON Flux_Retard(no_dossier_credit)"

    db.Execute "CREATE TABLE Archive_Retard (" & _
               "booking TEXT(20), " & _
               "no_dossier_credit TEXT(40), " & _
               "date_debut DATETIME, " & _
               "date_fin DATETIME, " & _
               "nb_jours_total LONG, " & _
               "pire_insuffisance DOUBLE, " & _
               "date_pire_insuffisance DATETIME)", dbFailOnError
    db.Execute "CREATE INDEX idx_arch_booking ON Archive_Retard(booking)"
    db.Execute "CREATE INDEX idx_arch_dossier ON Archive_Retard(no_dossier_credit)"
    db.Execute "CREATE INDEX idx_arch_datefin ON Archive_Retard(date_fin)"
    On Error GoTo 0
End Sub

' ====== CHARGER LE FLUX EN MÉMOIRE ======
Private Function LoadFluxIntoDict(db As DAO.Database) As Object
    Dim d As Object: Set d = CreateObject("Scripting.Dictionary")
    Dim rs As DAO.Recordset
    Set rs = db.OpenRecordset("SELECT * FROM Flux_Retard", dbOpenSnapshot)
    Do While Not rs.EOF
        Dim key As String
        key = MakeKey(rs!booking, rs!no_dossier_credit)
        Dim rec As Variant
        rec = Array( _
            rs!booking, rs!no_dossier_credit, rs!date_debut, _
            NzLng(rs!nb_jours), NzDbl(rs!pire_insuffisance), rs!date_pire_insuffisance, _
            NzDbl(rs!insuffisance_du_jour), rs!last_production_date _
        )
        d(key) = rec
        rs.MoveNext
    Loop
    rs.Close
    Set rs = Nothing
    Set LoadFluxIntoDict = d
End Function

' ====== UPSERT DES RETARDS DU JOUR ======
Private Sub UpsertTodayOverdue(db As DAO.Database, flux As Object, overdue As Object, prodDate As Date)
    Dim key As Variant
    For Each key In overdue.Keys
        Dim info As Variant
        info = overdue(key) ' (booking, dossier, pd, insuff)

        Dim booking As String: booking = CStr(info(0))
        Dim dossier As String: dossier = CStr(info(1))
        Dim insuff As Double: insuff = CDbl(info(3))

        If Not flux.Exists(key) Then
            ' INSERT
            Dim sqlI As String
            sqlI = "INSERT INTO Flux_Retard (booking, no_dossier_credit, date_debut, nb_jours, " & _
                   "pire_insuffisance, date_pire_insuffisance, insuffisance_du_jour, last_production_date) " & _
                   "VALUES (?,?,?,?,?,?,?,?)"
            Dim qI As DAO.QueryDef
            Set qI = db.CreateQueryDef("", sqlI)
            qI.Parameters(0).Value = booking
            qI.Parameters(1).Value = dossier
            qI.Parameters(2).Value = prodDate
            qI.Parameters(3).Value = 1
            qI.Parameters(4).Value = insuff
            qI.Parameters(5).Value = prodDate
            qI.Parameters(6).Value = insuff
            qI.Parameters(7).Value = prodDate
            qI.Execute dbFailOnError
            qI.Close

            ' Miroir en mémoire
            flux(key) = Array(booking, dossier, prodDate, CLng(1), insuff, prodDate, insuff, prodDate)
        Else
            ' UPDATE
            Dim rec As Variant: rec = flux(key)
            Dim lastPD As Date: lastPD = rec(7)
            Dim nb As Long: nb = CLng(rec(3))
            Dim delta As Long: delta = 0
            If prodDate > lastPD Then delta = DateDiff("d", lastPD, prodDate)
            If delta < 0 Then delta = 0

            nb = nb + delta

            Dim pire As Double: pire = CDbl(rec(4))
            Dim datePire As Date: datePire = rec(5)
            If insuff < pire Then
                pire = insuff
                datePire = prodDate
            End If

            Dim sqlU As String
            sqlU = "UPDATE Flux_Retard SET nb_jours=?, insuffisance_du_jour=?, " & _
                   "pire_insuffisance=?, date_pire_insuffisance=?, last_production_date=? " & _
                   "WHERE booking=? AND no_dossier_credit=?"
            Dim qU As DAO.QueryDef
            Set qU = db.CreateQueryDef("", sqlU)
            qU.Parameters(0).Value = nb
            qU.Parameters(1).Value = insuff
            qU.Parameters(2).Value = pire
            qU.Parameters(3).Value = datePire
            qU.Parameters(4).Value = prodDate
            qU.Parameters(5).Value = booking
            qU.Parameters(6).Value = dossier
            qU.Execute dbFailOnError
            qU.Close

            rec = Array(rec(0), rec(1), rec(2), nb, pire, datePire, insuff, prodDate)
            flux(key) = rec
        End If
    Next key
End Sub

' ====== ARCHIVER CE QUI SORT DU FLUX ======
Private Sub CloseResolvedToArchive(db As DAO.Database, flux As Object, overdue As Object, prodDate As Date)
    Dim key As Variant
    For Each key In flux.Keys
        If Not overdue.Exists(key) Then
            Dim rec As Variant: rec = flux(key)
            Dim booking As String: booking = CStr(rec(0))
            Dim dossier As String: dossier = CStr(rec(1))
            Dim dateDebut As Date: dateDebut = rec(2)
            Dim nbTot As Long: nbTot = CLng(rec(3))
            Dim pire As Double: pire = CDbl(rec(4))
            Dim datePire As Date: datePire = rec(5)

            Dim dateFin As Date
            dateFin = DateAdd("d", -1, prodDate) ' le jour où il n'est plus en retard ne compte pas

            ' Insert Archive
            Dim sqlA As String
            sqlA = "INSERT INTO Archive_Retard (booking, no_dossier_credit, date_debut, date_fin, nb_jours_total, pire_insuffisance, date_pire_insuffisance) " & _
                   "VALUES (?,?,?,?,?,?,?)"
            Dim qA As DAO.QueryDef
            Set qA = db.CreateQueryDef("", sqlA)
            qA.Parameters(0).Value = booking
            qA.Parameters(1).Value = dossier
            qA.Parameters(2).Value = dateDebut
            qA.Parameters(3).Value = dateFin
            qA.Parameters(4).Value = nbTot
            qA.Parameters(5).Value = pire
            qA.Parameters(6).Value = datePire
            qA.Execute dbFailOnError
            qA.Close

            ' Delete Flux
            db.Execute "DELETE FROM Flux_Retard WHERE booking='" & Replace(booking, "'", "''") & _
                       "' AND no_dossier_credit='" & Replace(dossier, "'", "''") & "'", dbFailOnError
        End If
    Next key
End Sub

' ====== ÉCRITURE DES COLONNES SUR LA FEUILLE ======
Private Sub WriteSheetCounters(ws As Worksheet, db As DAO.Database, overdue As Object)
    Dim colB As Long: colB = FindColumn(ws, "Booking")
    Dim colDossier As Long: colDossier = FindColumn(ws, "NO DOSSIER CREDIT")
    If colB = 0 Or colDossier = 0 Then Err.Raise 5, , "Colonnes Booking/NO DOSSIER CREDIT introuvables."

    ' Ajouter colonnes à droite
    Dim lastCol As Long: lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    Dim colNb As Long: colNb = lastCol + 1
    Dim colDeb As Long: colDeb = lastCol + 2
    ws.Cells(1, colNb).Value = "NB Jours de retard"
    ws.Cells(1, colDeb).Value = "Date de début de retard"

    ' Préparer un recordset pour lookup rapide
    Dim rs As DAO.Recordset
    Set rs = db.OpenRecordset("SELECT booking, no_dossier_credit, nb_jours, date_debut FROM Flux_Retard", dbOpenSnapshot)

    Dim map As Object: Set map = CreateObject("Scripting.Dictionary")
    Do While Not rs.EOF
        Dim k As String
        k = MakeKey(rs!booking, rs!no_dossier_credit)
        map(k) = Array(NzLng(rs!nb_jours), rs!date_debut)
        rs.MoveNext
    Loop
    rs.Close: Set rs = Nothing

    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, colB).End(xlUp).Row
    Dim r As Long, key As String
    For r = 2 To lastRow
        If Not IsEmpty(ws.Cells(r, colB)) And Not IsEmpty(ws.Cells(r, colDossier)) Then
            key = MakeKey(CStr(ws.Cells(r, colB).Value), CStr(ws.Cells(r, colDossier).Value))
            If map.Exists(key) Then
                ws.Cells(r, colNb).Value = map(key)(0)
                ws.Cells(r, colDeb).Value = map(key)(1)
            Else
                ws.Cells(r, colNb).Value = 0
                ws.Cells(r, colDeb).ClearContents
            End If
        End If
    Next r

    ws.Columns(colNb).EntireColumn.AutoFit
    ws.Columns(colDeb).EntireColumn.AutoFit
End Sub

' ====== UTILS ======
Private Function NzDbl(v) As Double
    If IsNull(v) Or IsEmpty(v) Then
        NzDbl = 0#
    Else
        NzDbl = CDbl(v)
    End If
End Function

Private Function NzLng(v) As Long
    If IsNull(v) Or IsEmpty(v) Then
        NzLng = 0
    Else
        NzLng = CLng(v)
    End If
End Function


Ajout du bouton : Insertion > Formes > Bouton ou forme, clic droit > Affecter une macro… > RunDailyUpdate.

5) Reporting (exemples requêtes Access)

Âge moyen des retards en cours par Booking

SELECT booking, AVG(nb_jours) AS avg_nb_jours
FROM Flux_Retard
GROUP BY booking
ORDER BY avg_nb_jours DESC;


Top 20 pires insuffisances historiques

SELECT TOP 20 booking, no_dossier_credit, pire_insuffisance, date_pire_insuffisance, nb_jours_total
FROM Archive_Retard
ORDER BY pire_insuffisance ASC;  -- plus négatif d’abord


Volume d’épisodes clos par mois

SELECT Format(date_fin, "yyyy-mm") AS mois, COUNT(*) AS nb_episodes, SUM(nb_jours_total) AS jours_cumules
FROM Archive_Retard
GROUP BY Format(date_fin, "yyyy-mm")
ORDER BY mois DESC;

6) Pourquoi cette solution est “propre & rapide”

Tables minimales (flux + archive) + index utiles → accès très rapide et maintenance simple.

Idempotent : tu cliques le bouton chaque jour, il calcule les deltas via DateDiff et ne double-compte pas.

Robuste aux trous de dates (si un jour n’a pas tourné, nb_jours rattrape).

Faible couplage : Access stocke l’historique, Excel reste l’interface d’exploitation quotidienne.

Écriture en feuille post-update pour ton suivi opérationnel.

Si tu veux, je peux aussi te donner :

une question Access pour reconstituer l’état à une date donnée,

une table Snapshot_Daily optionnelle pour stats journalières,

ou l’export automatique vers un Power BI / un tableau croisé dynamiques.

Dis-moi juste si tu veux ces bonus et je te l’intègre.