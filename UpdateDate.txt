bonne nouvelle : ton code est presque bon pour lâ€™usage â€œmulti-places dans la mÃªme journÃ©eâ€, mais deux points expliquent lâ€™anomalie que tu observes :
	1. TEST_MODE=True + BumpSimDate
Dans Main_Histo, tu as :

If TEST_MODE Then Call BumpSimDate(cn)

â†’ Chaque exÃ©cution avance la date simulÃ©e dâ€™un jour (TEST_STEP_DAYS=1).
Donc si tu fais IND (run #1) puis CFM (run #2), tu te retrouves au jour J+1 pour CFM. Dâ€™oÃ¹ lâ€™impression que â€œcâ€™est un nouveau jourâ€.
	2. ClÃ´ture â€œclÃ© disparueâ€ basÃ©e sur lâ€™absence dans T_TODAY (t.Booking IS NULL)
Les requÃªtes de BuildCloseBuffer (et la purge #8) considÃ¨rent quâ€™une clÃ© â€œdisparueâ€ aujourdâ€™hui doit Ãªtre clÃ´turÃ©e.
Si tu charges une seule place (ex. CFM) dans T_TODAY, toutes les autres places (IND, CAI, â€¦) sont absentes â†’ elles sont vues comme â€œdisparuesâ€ et donc clÃ´turÃ©es Ã  tort.


Ce que tu veux
	â€¢ MÃªme journÃ©e, charger IND puis CAI puis CFM (ou bien une feuille ALL) sans:
		â—‹ avancer la date,
		â—‹ clÃ´turer les places non traitÃ©es dans le run courant,
		â—‹ rÃ©-importer deux fois le mÃªme (Booking, NDC, Date).
Ce que ton code garantit dÃ©jÃ  (ğŸ‘)
	â€¢ Pas de doublon en historique : AppendHistory a une contrainte unique (Booking,NDC,Nature,Production Date) + WHERE NOT EXISTS.
	â€¢ Pas de double incrÃ©ment : les continuations utilisent t.[Production Date] > f.*_LastUpdateDate.
2 changements trÃ¨s ciblÃ©s
A) Ne pas avancer la date â€œpar runâ€
En prod, mets TEST_MODE = False.
Si tu veux garder le mode test, nâ€™avance la date quâ€™une fois par jour, pas Ã  chaque run de place.
Le plus simple (immÃ©diat) :

' Dans Main_Histo, remplace :
If TEST_MODE Then Call BumpSimDate(cn)

' par :
If TEST_MODE Then
    ' Avancer la date uniquement quand tu lâ€™as dÃ©cidÃ© (ex. aprÃ¨s ALL)
    ' Sinon, commente cette ligne pendant les runs place par place.
    'Call BumpSimDate(cn)
End If

(ou garde un bouton â€œAvancer jourâ€ sÃ©parÃ© qui appelle BumpSimDate manuellement).
B) Restreindre clÃ´tures & purge Ã  la/aux place(s) prÃ©sentes dans T_TODAY
Ajoute un petit filtre de scope â€œbookings du jourâ€ dans BuildCloseBuffer et Purge FLUX (#8).
1) Helper SQL

Private Function ScopeBookingsSQL() As String
    ScopeBookingsSQL = " AND f.Booking IN (SELECT DISTINCT Booking FROM " & T_TODAY & ")"
End Function

2) BuildCloseBuffer â€“ sÃ©lection des clÃ©s Ã  clÃ´turer
Avant :

... 
WHERE (f.VG_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance VG] >= 0))
   OR (f.AM_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance AM] >= 0))
   OR (f.SL_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance SL] >= 0));

AprÃ¨s (on ajoute le scope) :

cn.Execute _
  "INSERT INTO " & T_CLOSE & " (Booking, [NO DOSSIER CREDIT]) " & _
  "SELECT DISTINCT f.Booking, f.[NO DOSSIER CREDIT] " & _
  "FROM " & T_FLUX & " AS f " & _
  "LEFT JOIN " & T_TODAY & " AS t ON f.Booking=t.Booking AND f.[NO DOSSIER CREDIT]=t.[NO DOSSIER CREDIT] " & _
  "WHERE (f.VG_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance VG] >= 0)) " & _
  "   OR (f.AM_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance AM] >= 0)) " & _
  "   OR (f.SL_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance SL] >= 0))" & _
  ScopeBookingsSQL() & ";"

	RÃ©sultat : seules les places prÃ©sentes dans T_TODAY sont Ã©ligibles Ã  la clÃ´ture â€œdisparueâ€.
(Les UPDATE suivants se basent sur T_CLOSE : le scope est donc dÃ©jÃ  respectÃ©.)
3) Purge FLUX (#8) â€” ajouter le mÃªme scope
Avant :

UPDATE T_Flux AS f LEFT JOIN T_Today AS t ON ...
SET ... 
WHERE f.VG_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance VG] >= 0);

AprÃ¨s :

cn.Execute _
  "UPDATE " & T_FLUX & " AS f LEFT JOIN " & T_TODAY & " AS t " & _
  "ON f.Booking=t.Booking AND f.[NO DOSSIER CREDIT]=t.[NO DOSSIER CREDIT] " & _
  "SET f.VG_StartDate=Null, f.VG_LastUpdateDate=Null, f.VG_NbJoursRetard=Null, f.VG_WorstInsuffisance=Null, f.VG_DateWorstInsuffisance=Null, f.VG_LastInsuffisance=Null, f.VG_EndDate=Null " & _
  "WHERE f.VG_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance VG] >= 0)" & ScopeBookingsSQL() & ";"

cn.Execute _
  "UPDATE " & T_FLUX & " AS f LEFT JOIN " & T_TODAY & " AS t " & _
  "ON f.Booking=t.Booking AND f.[NO DOSSIER CREDIT]=t.[NO DOSSIER CREDIT] " & _
  "SET f.AM_StartDate=Null, f.AM_LastUpdateDate=Null, f.AM_NbJoursRetard=Null, f.AM_WorstInsuffisance=Null, f.AM_DateWorstInsuffisance=Null, f.AM_LastInsuffisance=Null, f.AM_EndDate=Null " & _
  "WHERE f.AM_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance AM] >= 0)" & ScopeBookingsSQL() & ";"

cn.Execute _
  "UPDATE " & T_FLUX & " AS f LEFT JOIN " & T_TODAY & " AS t " & _
  "ON f.Booking=t.Booking AND f.[NO DOSSIER CREDIT]=t.[NO DOSSIER CREDIT] " & _
  "SET f.SL_StartDate=Null, f.SL_LastUpdateDate=Null, f.SL_NbJoursRetard=Null, f.SL_WorstInsuffisance=Null, f.SL_DateWorstInsuffisance=Null, f.SL_LastInsuffisance=Null, f.SL_EndDate=Null " & _
  "WHERE f.SL_StartDate IS NOT NULL AND (t.Booking IS NULL OR t.[Insuffisance SL] >= 0)" & ScopeBookingsSQL() & ";"

Et pour Ãªtre parfaitement safe, restreins aussi le DELETE final :

cn.Execute _
  "DELETE FROM " & T_FLUX & " " & _
  "WHERE VG_StartDate IS NULL AND AM_StartDate IS NULL AND SL_StartDate IS NULL " & _
  "AND Booking IN (SELECT DISTINCT Booking FROM " & T_TODAY & ");"



RÃ©sumÃ© : est-ce que ton code faisait dÃ©jÃ  Ã§a ?
	â€¢ Non, pas complÃ¨tement.
		â—‹ Il dÃ©jÃ  Ã©vite les doublons (History & continuations âœ”ï¸).
		â—‹ Mais en mode test il avance la date Ã  chaque run â†’ effet â€œnouveau jourâ€.
		â—‹ Et surtout, la clÃ´ture â€œdisparueâ€ sâ€™applique Ã  toutes les places non prÃ©sentes dans T_TODAY pendant ce run â†’ clÃ´tures Ã  tort quand tu charges une place Ã  la fois.
Avec les 2 micro-patchs ci-dessus :
	â€¢ tu peux enchaÃ®ner IND â†’ CAI â†’ CFM dans la mÃªme journÃ©e sans bruit,
	â€¢ ou faire ALL en un seul passage,
	â€¢ sans doubler lâ€™historique, sans clÃ´tures parasites,
	â€¢ et sans changer le reste de ta chaÃ®ne.


#

avec ces modifs on est d accord que si en prod et meme journÃ©e si j'importe en premier IND, donc j'aurais des lignes en flux et j'importe ensuite CAI, en flux j'aurais IND et CAI ( et pas comme avant IND en archive)



oui ğŸ‘
Avec les modifs proposÃ©es :


Pas dâ€™auto-avancement de la date (en PROD TEST_MODE=False, et pas de BumpSimDate),


ClÃ´ture/purge limitÃ©es aux places prÃ©sentes dans T_TODAY grÃ¢ce au filtre :
... WHERE ...  /* conditions de close */
AND f.Booking IN (SELECT DISTINCT Booking FROM T_TODAY)

(ajoutÃ© dans BuildCloseBuffer et dans les 3 UPDATE de purge + le DELETE final),


â¡ï¸ alors, mÃªme journÃ©e :


Run 1 : tu importes IND â†’ les dossiers IND restent en FLUX (sâ€™ouvrent/continuent si insuff < 0).


Run 2 : tu importes CAI â†’ seuls les dossiers CAI sont Ã©valuÃ©s pour close/purge.
Les dossiers IND ne sont pas vus comme â€œdisparusâ€ (puisquâ€™on ne scope que Booking IN T_TODAY), donc restent en FLUX.


RÃ©sultat : en FLUX tu as IND + CAI, et tu nâ€™as plus le cas dâ€™IND envoyÃ© en Archive juste parce que tu traites CAI dans un run sÃ©parÃ©.


Bonus garanties :


Pas de doublons dâ€™historique : AppendHistory est dÃ©jÃ  protÃ©gÃ© par lâ€™unicitÃ© (Booking, NDC, Nature, Production Date).


Pas de sur-incrÃ©ment de jours : les continuations exigent t.[Production Date] > f.*_LastUpdateDate.


Si tu fais une feuille ALL, le scope couvre toutes les places â†’ les closes lÃ©gitimes se feront bien au global.


Donc oui, avec ces ajouts tu obtiens exactement le comportement attendu : IND reste en FLUX aprÃ¨s le run CAI de la mÃªme date.


#
et si je suis en prod et sans faire expre je reppui une deuxime sur histo et je suis IND, alors que je l'ai deja fait, Ã§a va faire un +1 sur les dÃ©passements en flux, donc avoir Ã  tor +2 sur la journÃ©e ?

Non â€” en PROD, si tu relances une 2áµ‰ fois le mÃªme jour sur la mÃªme place (IND), Ã§a ne rajoute pas +1 jour en FLUX.
Pourquoi :

Pas de rÃ©-insertion en FLUX : lâ€™INSERT ... WHERE NOT EXISTS empÃªche les doublons de clÃ©.

Pas de double incrÃ©ment de jours : les continuations exigent

... AND t.[Production Date] > f.*_LastUpdateDate


donc, au mÃªme jour, la condition est fausse â†’ aucun +1.
(MÃªme si lâ€™heure diffÃ¨re, DateDiff('d', ...) donnera 0 jour.)

Historique protÃ©gÃ© : AppendHistory a lâ€™unicitÃ© (Booking, NDC, Nature, Production Date) â†’ aucune 2áµ‰ ligne le mÃªme jour.

Pas dâ€™avance de date en PROD : BumpSimDate nâ€™est appelÃ© que si TEST_MODE=True.


Deux durcissements (recommandÃ©)

Pour Ãªtre 100% blindÃ©, tu peux rendre la logique strictement Â« jour Â» (sans ambiguÃ¯tÃ© dâ€™heure) :

Normaliser la date (sans lâ€™heure) dans T_Today

UPDATE T_Today SET [Production Date] = DateValue([Production Date]);


(ajoute cette ligne dans NormalizeToday aprÃ¨s tes autres UPDATE.)

RÃ¨gle de continuation Ã  la journÃ©e
Remplace, dans les 3 updates VG/AM/SL de continuation, la condition :

... AND t.[Production Date] > f.VG_LastUpdateDate


par

... AND DateDiff('d', f.VG_LastUpdateDate, t.[Production Date]) > 0


(idem pour AM/SL).
Lâ€™incrÃ©ment est dÃ©jÃ  + DateDiff('d', ...), donc tu restes cohÃ©rent et immunisÃ© Ã  lâ€™heure.