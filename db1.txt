Public Sub ImportLLCR_One_DuckDB(ByVal csvPath As String)
    On Error GoTo Fail

    Dim db As New cDuck, duckPath As String, tbl As String
    Dim ws As Worksheet, v As Variant
    Dim booking As String, basePath As String, pos As Long

    ' Param√®tres
    duckPath = ThisWorkbook.Path & "\prod.duckdb"
    tbl = "LLCR_One"

    ' Booking depuis le nom de fichier: LLCR_<BOOKING>.csv
    booking = Split(Mid$(csvPath, InStrRev(csvPath, "\") + 1), "_")(1)
    booking = Split(booking, ".")(0)

    ' Init DuckDB
    db.Init ThisWorkbook.Path
    db.OpenDuckDb duckPath

    ' Cr√©e/Remplace la table en lisant le CSV et en appliquant les nettoyages + cast
    db.Exec "DROP TABLE IF EXISTS """ & tbl & """;"

    db.Exec _
      "CREATE TABLE """ & tbl & """ AS " & _
      "WITH src AS (" & _
      "  SELECT * FROM read_csv_auto(" & _
      SqlQ(ToPosix(csvPath)) & ", " & _
      "  header=true, delim=';', sample_size=-1, ignore_errors=true)" & _
      ") " & _
      "SELECT " & _
      "  TRIM([MONTANT ENG/SUR])      AS [MONTANT ENG/SUR_txt], " & _
      "  TRIM([MONTANT LIMITE])       AS [MONTANT LIMITE_txt], " & _
      "  TRIM([MONTANT MIN SURETE])   AS [MONTANT MIN SURETE_txt], " & _
      "  TRIM([NO INTV PERE DU GRP RISQ]) AS [NO INTV PERE DU GRP RISQ], " & _
      "  TRIM([LIBELLE TYPE DE SURETE])   AS [LIBELLE TYPE DE SURETE], " & _
      "  " & SqlQ(booking) & "        AS [Booking], " & _
      "  -- Cast num√©rique robuste : retire espaces internes + apostrophes + g√®re la virgule d√©cimale" & _
      "  CAST(REPLACE(REPLACE(REPLACE([MONTANT ENG/SUR_txt], '''', ' '), ' ', ''), ',', '.') AS DOUBLE)  AS [MONTANT ENG/SUR], " & _
      "  CAST(REPLACE(REPLACE(REPLACE([MONTANT LIMITE_txt],  '''', ' '), ' ', ''), ',', '.') AS DOUBLE)  AS [MONTANT LIMITE], " & _
      "  CAST(REPLACE(REPLACE(REPLACE([MONTANT MIN SURETE_txt],'''', ' '), ' ', ''), ',', '.') AS DOUBLE) AS [MONTANT MIN SURETE] " & _
      "FROM src;"

    ' Affichage
    Set ws = EnsureSheet("DataImport")
    v = db.QueryFast("SELECT [NO INTV PERE DU GRP RISQ],[LIBELLE TYPE DE SURETE],[Booking]," & _
                     "[MONTANT ENG/SUR],[MONTANT LIMITE],[MONTANT MIN SURETE] FROM """ & tbl & """;")
    ArrayToSheet v, ws, "A1"

    db.CloseDuckDb
    Exit Sub
Fail:
    On Error Resume Next
    db.CloseDuckDb
    MsgBox "Erreur ImportLLCR_One_DuckDB: " & Err.Description & vbCrLf & Native_LastErrorText(), vbExclamation
End Sub

'************************************************

Public Sub ImportLLCR_All_DuckDB()
    On Error GoTo Fail

    Dim db As New cDuck, duckPath As String, base As String, tbl As String
    Dim ws As Worksheet, v As Variant
    Dim bookings, i As Long, sql As String, one As String, p As String

    duckPath = ThisWorkbook.Path & "\prod.duckdb"
    base = "P:\EXPORTS_GESTION\Gateway\LVAL\Input_LLCR\"
    tbl = "LLCR_ALL"

    bookings = Array("CAI", "CFM", "ESP", "HKG", "IND", "ITL", "LUX", "SNG")

    db.Init ThisWorkbook.Path
    db.OpenDuckDb duckPath
    db.Exec "DROP TABLE IF EXISTS """ & tbl & """;"

    ' Construit le SELECT normalis√© pour chaque fichier puis UNION ALL
    sql = "CREATE TABLE """ & tbl & """ AS " & vbCrLf

    For i = LBound(bookings) To UBound(bookings)
        p = base & "LLCR_" & bookings(i) & ".csv"
        one = _
          "WITH src AS (" & _
          "  SELECT * FROM read_csv_auto(" & SqlQ(ToPosix(p)) & ", header=true, delim=';', sample_size=-1, ignore_errors=true)" & _
          ") " & _
          "SELECT " & _
          "  TRIM([NO INTV PERE DU GRP RISQ]) AS [NO INTV PERE DU GRP RISQ], " & _
          "  TRIM([LIBELLE TYPE DE SURETE])   AS [LIBELLE TYPE DE SURETE], " & _
          "  " & SqlQ(bookings(i)) & "         AS [Booking], " & _
          "  CAST(REPLACE(REPLACE(REPLACE(TRIM([MONTANT ENG/SUR])     , '''',' '),' ',''), ',', '.') AS DOUBLE) AS [MONTANT ENG/SUR], " & _
          "  CAST(REPLACE(REPLACE(REPLACE(TRIM([MONTANT LIMITE])      , '''',' '),' ',''), ',', '.') AS DOUBLE) AS [MONTANT LIMITE], " & _
          "  CAST(REPLACE(REPLACE(REPLACE(TRIM([MONTANT MIN SURETE])  , '''',' '),' ',''), ',', '.') AS DOUBLE) AS [MONTANT MIN SURETE] "
        If i < UBound(bookings) Then
            sql = sql & one & vbCrLf & "UNION ALL " & vbCrLf
        Else
            sql = sql & one & ";"
        End If
    Next i

    db.Exec sql

    ' Affichage
    Set ws = EnsureSheet("DataImport")
    v = db.QueryFast("SELECT [NO INTV PERE DU GRP RISQ],[LIBELLE TYPE DE SURETE],[Booking]," & _
                     "[MONTANT ENG/SUR],[MONTANT LIMITE],[MONTANT MIN SURETE] FROM """ & tbl & """;")
    ArrayToSheet v, ws, "A1"

    db.CloseDuckDb
    Exit Sub
Fail:
    On Error Resume Next
    db.CloseDuckDb
    MsgBox "Erreur ImportLLCR_All_DuckDB: " & Err.Description & vbCrLf & Native_LastErrorText(), vbExclamation
End Sub


Private Function ToPosix(ByVal pathWin As String) As String
    Dim p$: p = Replace(pathWin, "\", "/")
    ToPosix = Replace(p, "'", "''")
End Function

Private Function EnsureSheet(ByVal name As String) As Worksheet
    On Error Resume Next
    Set EnsureSheet = ThisWorkbook.Sheets(name)
    On Error GoTo 0
    If EnsureSheet Is Nothing Then
        Set EnsureSheet = ThisWorkbook.Sheets.Add(After:=Sheets(Sheets.Count))
        EnsureSheet.Name = name
    End If
End Function

*******************************

N1 ‚Äî Ce que tu fais d√©j√† (tr√®s bien)

CREATE TABLE AS SELECT * FROM read_csv_auto('folder/*.csv', union_by_name=true, sample_size=-1, ‚Ä¶)

Simple, robuste.

Mais l‚Äôauto-d√©tection (s√©parateur/types) a un co√ªt.

N2 ‚Äî Plus rapide : √©viter l‚Äôauto-d√©tection

Fixe le s√©parateur.

Fournis le sch√©ma (types) ‚Üí saute totalement l‚Äôinf√©rence.

Fais les nettoyages inline dans le SELECT (pas d‚ÄôUPDATE apr√®s coup).

üëâ C‚Äôest le meilleur ratio vitesse/fiabilit√© pour tes rechargements complets.

N3 ‚Äî Ultime sur runs r√©p√©t√©s : Parquet (si tu r√©utilises souvent les m√™mes donn√©es)

1√®re passe : convertir tout le glob CSV en un Parquet (ou plusieurs).

Ensuite : CREATE TABLE ‚Ä¶ AS SELECT * FROM read_parquet('*.parquet') (lecture 5‚Äì10√ó plus rapide).

Int√©ressant si les CSV ne changent pas souvent.


Public Sub ImportLLCR_Folder_ReplaceAll_FastSchema()
    On Error GoTo Fail

    Dim db As New cDuck
    Dim duckPath$, folder$, table$, glob$, qtbl$
    Dim opts$, cols$
    Dim ws As Worksheet, v As Variant

    ' === CONFIG √Ä ADAPTER SI BESOIN ===
    duckPath = ThisWorkbook.Path & "\prod.duckdb"                         ' base DuckDB
    folder   = "P:\EXPORTS_GESTION\Gateway\LVAL\Input_LLCR"               ' dossier des LLCR_*.csv
    table    = "LLCR_Prod"                                                ' table finale
    ' ===================================

    qtbl = """" & Replace(table, """", """""") & """"

    ' Glob POSIX
    glob = Replace(folder, "\", "/"): If Right$(glob, 1) <> "/" Then glob = glob & "/"
    glob = Replace(glob & "LLCR_*.csv", "'", "''")

    ' 1) Sch√©ma explicite pour √©viter l‚Äôinf√©rence et aller vite
    '    (on ne garde que les colonnes utiles ; tu peux en ajouter si besoin)
    cols = "columns={" & _
           "'NO INTV PERE DU GRP RISQ':'VARCHAR'," & _
           "'LIBELLE TYPE DE SURETE':'VARCHAR'," & _
           "'MONTANT ENG/SUR':'VARCHAR'," & _
           "'MONTANT LIMITE':'VARCHAR'," & _
           "'MONTANT MIN SURETE':'VARCHAR'" & _
           "}"

    ' 2) Options lecture CSV : s√©parateur ';', union par nom, + colonne source
    opts = "header=true, delim=';', " & cols & ", " & _
           "ignore_errors=true, union_by_name=true, normalize_names=false, filename=true, sample_size=0"

    db.Init ThisWorkbook.Path
    db.OpenDuckDb duckPath

    ' Perfs
    On Error Resume Next
    db.Exec "PRAGMA threads=8;"
    db.Exec "PRAGMA memory_limit='2GB';"
    db.Exec "PRAGMA force_compression=ZSTD;"
    On Error GoTo Fail

    ' 3) CTAS avec nettoyages IN-LINE (TRIM + d√©cimales FR -> DOUBLE) + Booking depuis _filename
    db.Exec "DROP TABLE IF EXISTS " & qtbl & ";"
    db.Exec _
      "CREATE TABLE " & qtbl & " AS " & _
      "SELECT " & _
      "  TRIM([NO INTV PERE DU GRP RISQ])        AS [NO INTV PERE DU GRP RISQ]," & _
      "  TRIM([LIBELLE TYPE DE SURETE])          AS [LIBELLE TYPE DE SURETE]," & _
      "  /* Booking: extrait LLCR_<BOOKING>.csv depuis _filename */ " & _
      "  COALESCE(" & _
      "    regexp_extract(_filename, 'LLCR_([^.]+)\\.csv', 1)," & _
      "    regexp_extract(_filename, 'LLCR_([^.]+)\\.', 1)" & _
      "  ) AS [Booking]," & _
      "  /* Montants : trim, retire espaces/apostrophes, remplace ',' -> '.' puis CAST DOUBLE */ " & _
      "  CAST(REPLACE(REPLACE(REPLACE(TRIM([MONTANT ENG/SUR])    , '''',' '),' ',''), ',', '.') AS DOUBLE) AS [MONTANT ENG/SUR]," & _
      "  CAST(REPLACE(REPLACE(REPLACE(TRIM([MONTANT LIMITE])     , '''',' '),' ',''), ',', '.') AS DOUBLE) AS [MONTANT LIMITE]," & _
      "  CAST(REPLACE(REPLACE(REPLACE(TRIM([MONTANT MIN SURETE]) , '''',' '),' ',''), ',', '.') AS DOUBLE) AS [MONTANT MIN SURETE]" & _
      "FROM read_csv_auto('" & glob & "', " & opts & ");"

    ' Index utiles (silencieux si la colonne manque)
    On Error Resume Next
    db.Exec "CREATE INDEX IF NOT EXISTS idx_" & table & "_booking ON " & qtbl & " ([Booking]);"
    db.Exec "CREATE INDEX IF NOT EXISTS idx_" & table & "_pere    ON " & qtbl & " ([NO INTV PERE DU GRP RISQ]);"
    On Error GoTo 0

    ' Aper√ßu
    Set ws = EnsureSheet("DataImport")
    v = db.QueryFast( _
        "SELECT [Booking],[NO INTV PERE DU GRP RISQ],[LIBELLE TYPE DE SURETE]," & _
        "       [MONTANT ENG/SUR],[MONTANT LIMITE],[MONTANT MIN SURETE] " & _
        "FROM " & qtbl & " LIMIT 200;")
    ArrayToSheet v, ws, "A1"

    db.CloseDuckDb
    MsgBox "Import LLCR termin√© : " & table, vbInformation
    Exit Sub

Fail:
    On Error Resume Next
    db.CloseDuckDb
    MsgBox "Erreur Import LLCR: " & Err.Description & vbCrLf & Native_LastErrorText(), vbCritical
End Sub

parsing ind

Public Sub ImportLLCR_Folder_ReplaceAll_FastSchema_LocaleAware()
    On Error GoTo Fail

    Dim db As New cDuck
    Dim duckPath$, folder$, table$, glob$, qtbl$
    Dim opts$, cols$
    Dim ws As Worksheet, v As Variant

    ' === CONFIG ===
    duckPath = ThisWorkbook.Path & "\prod.duckdb"
    folder   = "P:\EXPORTS_GESTION\Gateway\LVAL\Input_LLCR"
    table    = "LLCR_Prod"
    qtbl     = """" & Replace(table, """", """""") & """"

    ' Glob POSIX
    glob = Replace(folder, "\", "/"): If Right$(glob, 1) <> "/" Then glob = glob & "/"
    glob = Replace(glob & "LLCR_*.csv", "'", "''")

    ' Sch√©ma minimal (√©vite l‚Äôinf√©rence = + rapide)
    cols = "columns={" & _
           "'NO INTV PERE DU GRP RISQ':'VARCHAR'," & _
           "'LIBELLE TYPE DE SURETE':'VARCHAR'," & _
           "'MONTANT ENG/SUR':'VARCHAR'," & _
           "'MONTANT LIMITE':'VARCHAR'," & _
           "'MONTANT MIN SURETE':'VARCHAR'" & _
           "}"

    ' Options read_csv_auto : ; + union_by_name + filename
    opts = "header=true, delim=';', " & cols & ", " & _
           "ignore_errors=true, union_by_name=true, normalize_names=false, filename=true, sample_size=0"

    db.Init ThisWorkbook.Path
    db.OpenDuckDb duckPath

    On Error Resume Next
    db.Exec "PRAGMA threads=8;"
    db.Exec "PRAGMA memory_limit='2GB';"
    db.Exec "PRAGMA force_compression=ZSTD;"
    On Error GoTo Fail

    ' -----------------------------------------------------------
    ' Parsing conditionnel des montants selon Booking :
    '  - IND (fr-FR):   retirer espaces/NBSP/' puis remplacer ',' -> '.' et CAST DOUBLE
    '  - autres (en-US): retirer espaces/NBSP/' ET virgules (milliers), garder '.' d√©cimal, CAST DOUBLE
    ' NB: regexp_replace(..., '[\s'']', '') supprime blancs (y c. NBSP) et apostrophes
    ' -----------------------------------------------------------
    db.Exec "DROP TABLE IF EXISTS " & qtbl & ";"
    db.Exec _
      "CREATE TABLE " & qtbl & " AS " & _
      "WITH src AS (" & _
      "  SELECT *, " & _
      "         COALESCE(regexp_extract(_filename, 'LLCR_([^.]+)\\.csv', 1), " & _
      "                  regexp_extract(_filename, 'LLCR_([^.]+)\\.', 1)) AS Booking " & _
      "  FROM read_csv_auto('" & glob & "', " & opts & ")" & _
      "), base AS (" & _
      "  SELECT " & _
      "    TRIM([NO INTV PERE DU GRP RISQ]) AS [NO INTV PERE DU GRP RISQ], " & _
      "    TRIM([LIBELLE TYPE DE SURETE])   AS [LIBELLE TYPE DE SURETE], " & _
      "    Booking, " & _
      "    /* ENG/SUR */ " & _
      "    CASE WHEN Booking='IND' THEN " & _
      "      CAST(REPLACE(regexp_replace(TRIM([MONTANT ENG/SUR]), '[\s'']', ''), ',', '.') AS DOUBLE) " & _
      "    ELSE " & _
      "      CAST(regexp_replace(TRIM([MONTANT ENG/SUR]), '[\s'',]', '') AS DOUBLE) " & _
      "    END AS [MONTANT ENG/SUR], " & _
      "    /* LIMITE */ " & _
      "    CASE WHEN Booking='IND' THEN " & _
      "      CAST(REPLACE(regexp_replace(TRIM([MONTANT LIMITE]),  '[\s'']', ''), ',', '.') AS DOUBLE) " & _
      "    ELSE " & _
      "      CAST(regexp_replace(TRIM([MONTANT LIMITE]),  '[\s'',]', '') AS DOUBLE) " & _
      "    END AS [MONTANT LIMITE], " & _
      "    /* MIN SURETE */ " & _
      "    CASE WHEN Booking='IND' THEN " & _
      "      CAST(REPLACE(regexp_replace(TRIM([MONTANT MIN SURETE]), '[\s'']', ''), ',', '.') AS DOUBLE) " & _
      "    ELSE " & _
      "      CAST(regexp_replace(TRIM([MONTANT MIN SURETE]), '[\s'',]', '') AS DOUBLE) " & _
      "    END AS [MONTANT MIN SURETE] " & _
      "  FROM src" & _
      ") " & _
      "SELECT * FROM base;"

    ' Index utiles
    On Error Resume Next
    db.Exec "CREATE INDEX IF NOT EXISTS idx_" & table & "_booking ON " & qtbl & " (Booking);"
    db.Exec "CREATE INDEX IF NOT EXISTS idx_" & table & "_pere    ON " & qtbl & " ([NO INTV PERE DU GRP RISQ]);"
    On Error GoTo 0

    ' Aper√ßu
    Set ws = EnsureSheet("DataImport")
    v = db.QueryFast("SELECT Booking,[NO INTV PERE DU GRP RISQ],[LIBELLE TYPE DE SURETE]," & _
                     "       [MONTANT ENG/SUR],[MONTANT LIMITE],[MONTANT MIN SURETE] " & _
                     "FROM " & qtbl & " LIMIT 200;")
    ArrayToSheet v, ws, "A1"

    db.CloseDuckDb
    MsgBox "Import LLCR (locale-aware) termin√© : " & table, vbInformation
    Exit Sub

Fail:
    On Error Resume Next
    db.CloseDuckDb
    MsgBox "Erreur Import LLCR: " & Err.Description & vbCrLf & Native_LastErrorText(), vbCritical
End Sub


Dim v As Variant
v = db.QueryFast("PRAGMA threads;")
ArrayToSheet v, ThisWorkbook.Worksheets(1), "A1"

v = db.QueryFast("PRAGMA memory_limit;")
ArrayToSheet v, ThisWorkbook.Worksheets(1), "B1"

v = db.QueryFast("PRAGMA force_compression;")
ArrayToSheet v, ThisWorkbook.Worksheets(1), "C1"


