Private Sub AddOrReuseListObject(ByVal wb As Workbook, ByVal queryName As String)
    Dim ws As Worksheet: Set ws = EnsureSheet(wb, SHEET_IMPORT)
    Dim lo As ListObject

    ' --- rechercher le ListObject par nom, sans On Error Resume Next
    Set lo = Nothing
    Dim t As ListObject
    For Each t In ws.ListObjects
        If StrComp(t.Name, TABLE_IMPORT, vbTextCompare) = 0 Then
            Set lo = t
            Exit For
        End If
    Next t

    If lo Is Nothing Then
        ' --- cr√©ation
        Dim newLO As ListObject
        Set newLO = ws.ListObjects.Add( _
            SourceType:=0, _
            Source:="OLEDB;Provider=" & PQ_PROVIDER & _
                    ";Data Source=" & PQ_SRC & _
                    ";Location=" & queryName & _
                    ";Extended Properties=""""")

        With newLO.QueryTable
            .CommandType = xlCmdSql
            .CommandText = Array("SELECT * FROM [" & queryName & "]")
            .AdjustColumnWidth = True
            .PreserveColumnInfo = True
            .Refresh BackgroundQuery:=False
        End With

        ' g√©rer l'unicit√© des noms au niveau du classeur
        SafeRenameListObject newLO, TABLE_IMPORT

    Else
        ' --- r√©utilisation / rebranchement
        With lo.QueryTable
            .Connection = "OLEDB;Provider=" & PQ_PROVIDER & _
                          ";Data Source=" & PQ_SRC & _
                          ";Location=" & queryName & _
                          ";Extended Properties="""""
            .CommandType = xlCmdSql
            .CommandText = Array("SELECT * FROM [" & queryName & "]")
            .Refresh BackgroundQuery:=False
        End With
    End If
End Sub

Private Sub SafeRenameListObject(ByVal lo As ListObject, ByVal targetName As String)
    ' Renomme en g√©rant les conflits au niveau du classeur
    If ListObjectNameExists(ThisWorkbook, targetName) Then
        ' soit on renomme l'ancien, soit on choisit un suffixe
        Dim i As Long, tryName As String
        For i = 1 To 999
            tryName = targetName & "_" & i
            If Not ListObjectNameExists(ThisWorkbook, tryName) Then
                lo.Name = tryName
                Exit Sub
            End If
        Next i
    Else
        lo.Name = targetName
    End If
End Sub

Private Function ListObjectNameExists(ByVal wb As Workbook, ByVal name As String) As Boolean
    Dim ws As Worksheet, lo As ListObject
    For Each ws In wb.Worksheets
        For Each lo In ws.ListObjects
            If StrComp(lo.Name, name, vbTextCompare) = 0 Then
                ListObjectNameExists = True
                Exit Function
            End If
        Next lo
    Next ws
End Function


Pourquoi √ßa r√®gle ton souci

Plus de doublon : une seule version de AddOrReuseListObject est utilis√©e partout.

Plus de On Error Resume Next qui cache la v√©rit√© : si le nom n‚Äôexiste pas, tu le vois.

La recherche n‚Äôutilise pas l‚Äôindex (ListObjects(1)) mais le nom exact.

Le renommage g√®re le conflit global de nom de table dans le classeur ; tu n‚Äôauras plus un tblDataImport_1 ‚Äúfant√¥me‚Äù que ta recherche ne retrouve pas.

Si malgr√© tout tu ne rentres pas dans le Else, ajoute un Debug.Print pour lister les noms de tableaux pr√©sents sur DataImport juste avant la recherche :

Dim loDbg As ListObject
For Each loDbg In ws.ListObjects
    Debug.Print "LO sur feuille "; ws.Name; " : "; loDbg.Name
Next loDbg


3. Robustesse Power Query / ListObject
‚úÖ G√©rer les connexions ‚Äúfant√¥mes‚Äù

Quand tu rafra√Æchis une requ√™te PQ par VBA, Excel laisse parfois des connexions orphelines.
Tu peux ajouter un petit nettoyage avant de cr√©er une nouvelle table :

Private Sub CleanUnusedConnections(ByVal wb As Workbook)
    Dim cn As WorkbookConnection
    For Each cn In wb.Connections
        If InStr(1, cn.Name, "Query - ") > 0 Then
            On Error Resume Next
            cn.Delete
            On Error GoTo 0
        End If
    Next cn
End Sub


1) Param√©trer et factoriser (√©viter le ‚Äúcopier-coller‚Äù M)

Cr√©e une fonction M r√©utilisable qui charge/clean un CSV et ajoute Booking. Tes requ√™tes ‚Äúsingle‚Äù et ‚Äúall‚Äù ne feront qu‚Äôappeler cette fonction.

// fxLoadCsv
(let filePath as text, culture as text, booking as text, optional delimiter as text) as table =>
let
    Delim = if delimiter <> null and delimiter <> "" then delimiter else ";",

    // lecture CSV sans typage implicite
    Source = Csv.Document(
        File.Contents(filePath),
        [Delimiter=Delim, Encoding=1252, QuoteStyle=QuoteStyle.Csv, ExtraValues=ExtraValues.Ignore]
    ),

    Headers = Table.PromoteHeaders(Source, [PromoteAllScalars=true]),

    // trim g√©n√©ral sur toutes les colonnes texte (dynamiquement)
    Schema   = Table.Schema(Headers),
    TextCols = Table.SelectRows(Schema, each [Kind] = "Text.Type")[Name],
    Trimmed  = Table.TransformColumns(
                  Headers,
                  List.Transform(TextCols, each {_, (t)=> if t=null then null else Text.Trim(t), type nullable text})
              ),

    // normalisation des colonnes mon√©taires cibl√©es
    MoneyCols = {"MONTANT ENG/SUR","MONTANT LIMITE","MONTANT MIN SURETE"},
    Nbsp = Character.FromNumber(160),
    CleanNumber = (x as any) as nullable number =>
        let
            t0 = if x=null then null else Text.From(x),
            t1 = if t0=null then null else Text.Replace(Text.Replace(Text.Replace(t0, "'", " "), Nbsp, ""), " ", ""),
            // g√©rer les montants n√©gatifs au format "(1234)"
            t2 = if t1<>null and Text.StartsWith(t1, "(") and Text.EndsWith(t1, ")")
                 then "-" & Text.Range(t1, 1, Text.Length(t1)-2) else t1,
            n  = try Number.FromText(t2, culture) otherwise null
        in n,

    // n'appliquer que si la colonne existe (√©vite les erreurs quand un CSV manque une colonne)
    ExistingMoney = List.Intersect({MoneyCols, Table.ColumnNames(Trimmed)}),
    Typed = if List.Count(ExistingMoney)=0
            then Trimmed
            else Table.TransformColumns(Trimmed, List.Transform(ExistingMoney, each {_, each CleanNumber(_), type nullable number})),

    WithBooking = Table.AddColumn(Typed, "Booking", each booking, type text)
in
    WithBooking)
	
	
	2) Requ√™te ‚ÄúSingle‚Äù compacte

Ta BuildM_Single peut se r√©sumer √† un appel de la fonction :

let
    // param√®tres inject√©s par VBA
    FilePath = "C:\Chemin\monfichier.csv",
    Culture  = "fr-FR",
    Booking  = "IND",
    Delim    = ";",

    Result = fxLoadCsv(FilePath, Culture, Booking, Delim)
in
    Result

3) Requ√™te ‚ÄúAll‚Äù sans r√©p√©tition avec List.Transform

Plut√¥t que r√©p√©ter des blocs pour chaque booking, fabrique la liste puis transforme :

let
    Root     = "P:\EXPORTS_GESTION\Gateway\LVAL\Input_LLCR\",
    Prefix   = "LLCR_",
    Bookings = {"CAI","CFM","ESP","HKG","IND","ITL","LUX","SNG"},

    CultureFor = (b as text) as text => if Text.Upper(b)="IND" then "fr-FR" else "en-US",

    Tables = List.Transform(
        Bookings,
        (b) => fxLoadCsv(Root & Prefix & b & ".csv", CultureFor(b), b, ";")
    ),

    Combined = Table.Combine(Tables)
in
    Combined


B√©n√©fices

Ajout/suppression d‚Äôun booking = tu modifies la liste, rien d‚Äôautre.

Cultures g√©r√©es au cas par cas.

4) Petites am√©liorations cibl√©es c√¥t√© M

D√©sactiver le typage implicite (InferTypes=false par d√©faut en proc√©dural) et faire ton typage explicitement (tu le fais d√©j√† via Number.FromText).

Ignorer les colonnes en trop dans les CSV avec ExtraValues=ExtraValues.Ignore (d√©j√† inclus ci-dessus).

PromoteHeaders avec PromoteAllScalars=true (tu le fais d√©j√†).

Appliquer les cleans seulement si la colonne existe (g√©r√© par ExistingMoney), √©vite les plantages si une colonne manque ponctuellement.

G√©rer les valeurs vides ‚Üí renvoyer null plut√¥t qu‚Äô"" pour de meilleures agr√©gations par la suite (g√©r√©).

Parameteriser les chemins dans Excel si tu veux √©viter le hard-code :
Root = Excel.CurrentWorkbook(){[Name="Param_Root"]}[Content]{0}[Value] (puis tu laisses le VBA entretenir ce param√®tre).

5) Int√©gration simple c√¥t√© VBA

Cr√©er une fois la fonction fxLoadCsv (query Power Query nomm√©e ‚ÄúfxLoadCsv‚Äù), puis, pour chaque import, ta macro ne fait qu‚Äôajouter/mettre √† jour la requ√™te ‚ÄúSingle‚Äù/‚ÄúAll‚Äù qui appelle la fonction.

Si tu pr√©f√®res rester 100% g√©n√©ration par VBA : g√©n√®re d‚Äôabord la query fxLoadCsv si elle n‚Äôexiste pas (tiny M ci-dessus), puis g√©n√®re les requ√™tes d‚Äôusage (2 ou 5 lignes chacune).

6) Bonus performance (√† utiliser avec parcimonie)

Table.Buffer juste apr√®s la lecture/source peut stabiliser les temps quand tu combines plusieurs fichiers :
Buffered = Table.Buffer(Headers) et travaille sur Buffered.
üëâ Utile surtout dans ‚ÄúAll‚Äù (plusieurs fichiers). √Ä tester, car parfois inutile sur de simples CSV.

Si tu veux, je peux te donner les cha√Ænes VBA (BuildM_Single / BuildM_All) qui √©mettent exactement ces M (avec √©chappement de guillemets), pr√™tes √† coller dans ton module actuel.




Oui ‚Äî on peut garder exactement les m√™mes fonctionnalit√©s mais g√©n√©rer un M plus compact et plus rapide (moins d‚Äô√©tapes, une seule passe de transformation, contr√¥le des colonnes existantes, parsing robuste).
Voici des versions ‚Äúfast‚Äù pr√™tes √† remplacer tes BuildM_Single et BuildM_AllBookings. Elles r√©duisent le nombre d‚Äô√©tapes PQ, √©vitent les scans multiples et g√®rent les colonnes manquantes sans planter.

‚ö° Version rapide : BuildM_Single

Une seule cha√Æne de transformations

Nettoyage des nombres en une fonction (apostrophes, espaces, NBSP, n√©gatifs de type (123)), puis Number.FromText avec la culture pass√©e

Application uniquement si la colonne existe

Private Function BuildM_Single(ByVal csvPath As String, ByVal culture As String, ByVal booking As String) As String
    Dim m As String
    m = _
    "let" & vbCrLf & _
    "  CleanNum = (x as any, cul as text) as nullable number =>" & vbCrLf & _
    "    let" & vbCrLf & _
    "      t0 = if x=null then null else Text.From(x)," & vbCrLf & _
    "      nbsp = Character.FromNumber(160)," & vbCrLf & _
    "      t1 = if t0=null then null else Text.Replace(Text.Replace(Text.Replace(t0, ""'"", "" ""), nbsp, """"), "" "", """")," & vbCrLf & _
    "      t2 = if t1<>null and Text.StartsWith(t1, ""("") and Text.EndsWith(t1, "")"") then ""-"" & Text.Range(t1, 1, Text.Length(t1)-2) else t1," & vbCrLf & _
    "      n  = try Number.FromText(t2, cul) otherwise null" & vbCrLf & _
    "    in n," & vbCrLf & _
    "  MoneyCols = {""MONTANT ENG/SUR"", ""MONTANT LIMITE"", ""MONTANT MIN SURETE""}," & vbCrLf & _
    "  Source = Csv.Document(File.Contents(""" & csvPath & """), [Delimiter="";"", Encoding=1252, QuoteStyle=QuoteStyle.Csv, ExtraValues=ExtraValues.Ignore])," & vbCrLf & _
    "  H = Table.PromoteHeaders(Source, [PromoteAllScalars=true])," & vbCrLf & _
    "  ExistingMoney = List.Intersect({MoneyCols, Table.ColumnNames(H)})," & vbCrLf & _
    "  // Trim toutes colonnes texte en une passe" & vbCrLf & _
    "  Schema = Table.Schema(H)," & vbCrLf & _
    "  TextCols = Table.SelectRows(Schema, each [Kind] = ""Text.Type"")[Name]," & vbCrLf & _
    "  Trimmed = Table.TransformColumns(H, List.Transform(TextCols, each {_, (t)=> if t=null then null else Text.Trim(t), type nullable text}))," & vbCrLf & _
    "  // Typage nombres seulement sur colonnes existantes" & vbCrLf & _
    "  Typed = if List.Count(ExistingMoney)=0 then Trimmed else " & vbCrLf & _
    "          Table.TransformColumns(Trimmed, List.Transform(ExistingMoney, each {_, (v)=> CleanNum(v, """ & culture & """), type nullable number}))," & vbCrLf & _
    "  Result = Table.AddColumn(Typed, """ & COL_BOOKING & """, each """ & booking & """, type text)" & vbCrLf & _
    "in" & vbCrLf & _
    "  Result"
    BuildM_Single = m
End Function

‚ö° Version rapide : BuildM_AllBookings

Z√©ro duplication : on mappe la liste des bookings

Culture par booking, m√™me nettoyage que ‚ÄúSingle‚Äù

Optionnel : Table.Buffer sur chaque table (d√©commenter si b√©n√©fique dans ton contexte)

Private Function BuildM_AllBookings(ByVal defaultCulture As String) As String
    Dim m As String, bookings As String
    ' Construit la liste {"CAI","CFM",...} depuis ALL_BOOKINGS
    Dim i As Long
    bookings = "{"
    For i = LBound(ALL_BOOKINGS) To UBound(ALL_BOOKINGS)
        bookings = bookings & """" & CStr(ALL_BOOKINGS(i)) & ""","
    Next i
    bookings = Left$(bookings, Len(bookings) - 1) & "}"

    m = _
    "let" & vbCrLf & _
    "  CleanNum = (x as any, cul as text) as nullable number =>" & vbCrLf & _
    "    let" & vbCrLf & _
    "      t0 = if x=null then null else Text.From(x)," & vbCrLf & _
    "      nbsp = Character.FromNumber(160)," & vbCrLf & _
    "      t1 = if t0=null then null else Text.Replace(Text.Replace(Text.Replace(t0, ""'"", "" ""), nbsp, """"), "" "", """")," & vbCrLf & _
    "      t2 = if t1<>null and Text.StartsWith(t1, ""("") and Text.EndsWith(t1, "")"") then ""-"" & Text.Range(t1, 1, Text.Length(t1)-2) else t1," & vbCrLf & _
    "      n  = try Number.FromText(t2, cul) otherwise null" & vbCrLf & _
    "    in n," & vbCrLf & _
    "  MoneyCols = {""MONTANT ENG/SUR"", ""MONTANT LIMITE"", ""MONTANT MIN SURETE""}," & vbCrLf & _
    "  Root = """ & ROOT_ALL & """," & vbCrLf & _
    "  Prefix = """ & ALL_PREFIX & """," & vbCrLf & _
    "  Bookings = " & bookings & "," & vbCrLf & _
    "  CultureFor = (b as text) as text => if Text.Upper(b) = ""IND"" then ""fr-FR"" else ""en-US""," & vbCrLf & _
    "  LoadOne = (b as text) as table =>" & vbCrLf & _
    "    let" & vbCrLf & _
    "      Path = Root & Prefix & b & "".csv""," & vbCrLf & _
    "      S = Csv.Document(File.Contents(Path), [Delimiter="";"", Encoding=1252, QuoteStyle=QuoteStyle.Csv, ExtraValues=ExtraValues.Ignore])," & vbCrLf & _
    "      H = Table.PromoteHeaders(S, [PromoteAllScalars=true])," & vbCrLf & _
    "      Schema = Table.Schema(H)," & vbCrLf & _
    "      TextCols = Table.SelectRows(Schema, each [Kind] = ""Text.Type"")[Name]," & vbCrLf & _
    "      Trimmed = Table.TransformColumns(H, List.Transform(TextCols, each {_, (t)=> if t=null then null else Text.Trim(t), type nullable text}))," & vbCrLf & _
    "      ExistingMoney = List.Intersect({MoneyCols, Table.ColumnNames(Trimmed)})," & vbCrLf & _
    "      Typed = if List.Count(ExistingMoney)=0 then Trimmed else " & vbCrLf & _
    "              Table.TransformColumns(Trimmed, List.Transform(ExistingMoney, each {_, (v)=> CleanNum(v, CultureFor(b)), type nullable number}))," & vbCrLf & _
    "      WithBooking = Table.AddColumn(Typed, """ & COL_BOOKING & """, each b, type text)" & vbCrLf & _
    "      //Buffered = Table.Buffer(WithBooking)" & vbCrLf & _
    "    in WithBooking," & vbCrLf & _
    "  Tables = List.Transform(Bookings, each LoadOne(_))," & vbCrLf & _
    "  Combined = Table.Combine(Tables)" & vbCrLf & _
    "in" & vbCrLf & _
    "  Combined"
    BuildM_AllBookings = m
End Function


Remarque : si tu as beaucoup de fichiers et observes des va-et-vient disque, essaie la version avec Table.Buffer(WithBooking) (d√©commente la ligne). Selon les cas, √ßa peut soit acc√©l√©rer, soit √™tre inutile ‚Äî √† tester.

Pourquoi c‚Äôest plus rapide

Moins d‚Äô√©tapes mat√©rialis√©es : on encha√Æne les op√©rations dans une seule passe de transformation, au lieu d‚Äôavoir 5‚Äì6 niveaux (Trim, Replace, Transform, Typed, etc.).

Transformations cibl√©es : on ne touche qu‚Äôaux colonnes existantes, et on n‚Äôapplique le parse num√©rique qu‚Äôaux colonnes mon√©taires.

List.Transform au lieu de r√©p√©ter des blocs : Power Query optimise mieux des listes de transformations que des √©tapes nomm√©es multiples.

QuoteStyle.Csv + ExtraValues.Ignore : parseur CSV plus robuste/rapide et tol√©rant (cols suppl√©mentaires ignor√©es).

Culture en param√®tre : Number.FromText fait le typage final sans multiple remplacements.

Si tu veux aller au bout de l‚Äôoptimisation, on peut :

sortir la fonction CleanNum dans une requ√™te-fonction M partag√©e (fxCleanNum) et la r√©utiliser (√ßa clarifie encore).

exposer Delimiter et Encoding en param√®tres si certains bookings ne sont pas en ; ou 1252.

Tu veux que je te fournisse aussi la version qui cr√©e une query-fonction fxLoadCsv une fois pour toutes, puis des BuildM_* ultra-courts qui ne font que l‚Äôappeler ?

Oui, on peut grappiller encore pas mal de perf. Si ton PC est ‚Äúlent‚Äù et/ou les fichiers sont sur un lecteur r√©seau (P:\), les leviers les plus efficaces sont :

Priorit√©s (du + gros gain au + petit)

√âviter le r√©seau pendant la lecture

Copie le CSV sur un dossier local temporaire (ex: %TEMP%) et pointe Power Query dessus.

Ou, c√¥t√© M, mets un Binary.Buffer(File.Contents(...)) pour charger le binaire en m√©moire d‚Äôun coup (super utile sur r√©seau/antivirus).

R√©duire au plus t√¥t

Si tu n‚Äôas pas besoin de toutes les colonnes, fais un Table.SelectColumns avant toute autre transfo.

Moins de colonnes = moins de texte √† trimmer = typage plus rapide.

√âviter Table.Schema (co√ªteux)

Si tu connais la/les colonnes texte √† ‚Äútrim‚Äù, cible-les directement au lieu d‚Äôinspecter le sch√©ma.

Idem pour les colonnes num√©riques : liste fixe -> une passe.

Bufferiser intelligemment

Pour chaque fichier : Binary.Buffer (binaire) + √©ventuellement Table.Buffer juste apr√®s les transformations essentielles (avant Table.Combine).

Ne bufferise pas tout et n‚Äôimporte quoi : 1‚Äì2 buffers bien plac√©s suffisent.

Param√®tres Power Query / Excel

Excel > Options > Donn√©es :

Activer Chargement de donn√©es rapide (Fast Data Load)

Activer le chargement parall√®le

D√©sactiver le t√©l√©chargement des aper√ßus en arri√®re-plan

Param√®tres de confidentialit√© : si tes sources sont de confiance, r√®gle sur Aucune pour √©viter la barri√®re de confidentialit√© (√ßa acc√©l√®re souvent les merges/combine).

D√©sactiver les ‚Äúcosm√©tiques‚Äù Excel

.AdjustColumnWidth = False et .PreserveColumnInfo = False c√¥t√© QueryTable.

Tu le fais d√©j√† en partie; compl√®te pour √©viter les recalculs d‚Äôaffichage.

M ‚Äúultra-rapide‚Äù (mono-fichier) ‚Äì sans Table.Schema

Suppose que tu connais:

Les colonnes num√©riques √† parser (MoneyCols)

Optionnel : la liste de colonnes √† garder (KeepCols) ‚Äì commente si tu veux tout garder

Private Function BuildM_Single(ByVal csvPath As String, ByVal culture As String, ByVal booking As String) As String
    Dim m As String
    m = _
    "let" & vbCrLf & _
    "  // Liste fixe (plus rapide que d√©tecter)" & vbCrLf & _
    "  MoneyCols = {""MONTANT ENG/SUR"", ""MONTANT LIMITE"", ""MONTANT MIN SURETE""}," & vbCrLf & _
    "  // Optionnel: garde seulement ce qui sert (plus rapide si pertinent)" & vbCrLf & _
    "  KeepCols = null, // ex: {""COL1"",""COL2"",""MONTANT LIMITE"",""MONTANT ENG/SUR""}" & vbCrLf & _
    "  CleanNum = (x as any, cul as text) as nullable number =>" & vbCrLf & _
    "    let" & vbCrLf & _
    "      t0 = if x=null then null else Text.From(x)," & vbCrLf & _
    "      nbsp = Character.FromNumber(160)," & vbCrLf & _
    "      t1 = if t0=null then null else Text.Replace(Text.Replace(Text.Replace(t0, ""'"", "" ""), nbsp, """"), "" "", """")," & vbCrLf & _
    "      t2 = if t1<>null and Text.StartsWith(t1, ""("") and Text.EndsWith(t1, "")"") then ""-"" & Text.Range(t1, 1, Text.Length(t1)-2) else t1," & vbCrLf & _
    "      n  = try Number.FromText(t2, cul) otherwise null" & vbCrLf & _
    "    in n," & vbCrLf & _
    "  Bin = Binary.Buffer(File.Contents(""" & csvPath & """))," & vbCrLf & _
    "  Src = Csv.Document(Bin, [Delimiter="";"", Encoding=1252, QuoteStyle=QuoteStyle.Csv, ExtraValues=ExtraValues.Ignore])," & vbCrLf & _
    "  H = Table.PromoteHeaders(Src, [PromoteAllScalars=true])," & vbCrLf & _
    "  // Optionnel: coupe t√¥t" & vbCrLf & _
    "  Cut = if KeepCols=null then H else Table.SelectColumns(H, KeepCols, MissingField.Ignore)," & vbCrLf & _
    "  // Trim cibl√©: si tu sais quelles colonnes texte il faut nettoyer" & vbCrLf & _
    "  // Exemple: TrimCols = {""LIBELLE TYPE DE SURETE"", ""NO INTV PERE DU GRP RISQ""}" & vbCrLf & _
    "  TrimCols = {}, " & vbCrLf & _
    "  Trimmed = if List.Count(TrimCols)=0 then Cut else " & vbCrLf & _
    "            Table.TransformColumns(Cut, List.Transform(TrimCols, each {_, (t)=> if t=null then null else Text.Trim(t), type nullable text}), MissingField.Ignore)," & vbCrLf & _
    "  ExistingMoney = List.Intersect({MoneyCols, Table.ColumnNames(Trimmed)})," & vbCrLf & _
    "  Typed = if List.Count(ExistingMoney)=0 then Trimmed else " & vbCrLf & _
    "          Table.TransformColumns(Trimmed, List.Transform(ExistingMoney, each {_, (v)=> CleanNum(v, """ & culture & """), type nullable number}))," & vbCrLf & _
    "  Result = Table.AddColumn(Typed, """ & COL_BOOKING & """, each """ & booking & """, type text)" & vbCrLf & _
    "in" & vbCrLf & _
    "  Result"
    BuildM_Single = m
End Function


Pourquoi √ßa va plus vite que ta version pr√©c√©dente ?

Binary.Buffer √©vite les aller-retours disque r√©seau.

Pas de Table.Schema (inspection de sch√©ma) ‚Üí pas de passage suppl√©mentaire.

Une seule passe de nettoyage num√©rique cibl√©e sur les colonnes qui existent.

Option de couper t√¥t les colonnes inutiles.

M ‚Äúultra-rapide‚Äù (multi-fichiers ‚ÄúALL‚Äù)

Binary.Buffer + option Table.Buffer juste avant le Combine

Pas de Table.Schema

Colonnes cibl√©es

Private Function BuildM_AllBookings(ByVal defaultCulture As String) As String
    Dim i As Long, bookings As String
    bookings = "{"
    For i = LBound(ALL_BOOKINGS) To UBound(ALL_BOOKINGS)
        bookings = bookings & """" & CStr(ALL_BOOKINGS(i)) & ""","
    Next i
    bookings = Left$(bookings, Len(bookings) - 1) & "}"

    Dim m As String
    m = _
    "let" & vbCrLf & _
    "  MoneyCols = {""MONTANT ENG/SUR"", ""MONTANT LIMITE"", ""MONTANT MIN SURETE""}," & vbCrLf & _
    "  KeepCols = null, // ex: {""COL1"",""COL2"",""MONTANT LIMITE"",""MONTANT ENG/SUR""}" & vbCrLf & _
    "  CleanNum = (x as any, cul as text) as nullable number =>" & vbCrLf & _
    "    let t0 = if x=null then null else Text.From(x)," & vbCrLf & _
    "        nbsp = Character.FromNumber(160)," & vbCrLf & _
    "        t1 = if t0=null then null else Text.Replace(Text.Replace(Text.Replace(t0, ""'"", "" ""), nbsp, """"), "" "", """")," & vbCrLf & _
    "        t2 = if t1<>null and Text.StartsWith(t1, ""("") and Text.EndsWith(t1, "")"") then ""-"" & Text.Range(t1, 1, Text.Length(t1)-2) else t1," & vbCrLf & _
    "        n  = try Number.FromText(t2, cul) otherwise null" & vbCrLf & _
    "    in n," & vbCrLf & _
    "  Root = """ & ROOT_ALL & """," & vbCrLf & _
    "  Prefix = """ & ALL_PREFIX & """," & vbCrLf & _
    "  Bookings = " & bookings & "," & vbCrLf & _
    "  CultureFor = (b as text) as text => if Text.Upper(b) = ""IND"" then ""fr-FR"" else ""en-US""," & vbCrLf & _
    "  LoadOne = (b as text) as table =>" & vbCrLf & _
    "    let" & vbCrLf & _
    "      Path = Root & Prefix & b & "".csv""," & vbCrLf & _
    "      Bin = Binary.Buffer(File.Contents(Path))," & vbCrLf & _
    "      S = Csv.Document(Bin, [Delimiter="";"", Encoding=1252, QuoteStyle=QuoteStyle.Csv, ExtraValues=ExtraValues.Ignore])," & vbCrLf & _
    "      H = Table.PromoteHeaders(S, [PromoteAllScalars=true])," & vbCrLf & _
    "      Cut = if KeepCols=null then H else Table.SelectColumns(H, KeepCols, MissingField.Ignore)," & vbCrLf & _
    "      ExistingMoney = List.Intersect({MoneyCols, Table.ColumnNames(Cut)})," & vbCrLf & _
    "      Typed = if List.Count(ExistingMoney)=0 then Cut else " & vbCrLf & _
    "              Table.TransformColumns(Cut, List.Transform(ExistingMoney, each {_, (v)=> CleanNum(v, CultureFor(b)), type nullable number}))," & vbCrLf & _
    "      WithBooking = Table.AddColumn(Typed, """ & COL_BOOKING & """, each b, type text)," & vbCrLf & _
    "      Buffered = Table.Buffer(WithBooking)" & vbCrLf & _
    "    in Buffered," & vbCrLf & _
    "  Tables = List.Transform(Bookings, each LoadOne(_))," & vbCrLf & _
    "  Combined = Table.Combine(Tables)" & vbCrLf & _
    "in" & vbCrLf & _
    "  Combined"
    BuildM_AllBookings = m
    BuildM_AllBookings = m
End Function

Bonus VBA (copie locale hyper simple)

Pour un mono-fichier import√© par l‚Äôutilisateur :

Private Function CopyToLocalTemp(ByVal srcPath As String) As String
    Dim fso As Object, tmp As String, nameOnly As String
    Set fso = CreateObject("Scripting.FileSystemObject")
    tmp = Environ$("TEMP")
    nameOnly = fso.GetFileName(srcPath)
    fso.CopyFile srcPath, tmp & "\" & nameOnly, True
    CopyToLocalTemp = tmp & "\" & nameOnly
End Function


Puis dans ton flux :

Dim localCsv As String
localCsv = CopyToLocalTemp(csvPath)
' et passe localCsv √† BuildM_Single au lieu de csvPath


Pour le mode ‚ÄúALL‚Äù, si P:\ est lent, pr√©-copie tous les fichiers n√©cessaires localement (1 seule passe), puis fais pointer la requ√™te sur le dossier local.

Est-ce qu‚Äôon est ‚Äúau max‚Äù ?

Si tu appliques Binary.Buffer, r√©duction de colonnes le plus t√¥t possible, pas de Table.Schema, et que tu charges depuis un disque local, tu es d√©j√† dans le haut du panier c√¥t√© Power Query.

Le reste du gain vient du mat√©riel (SSD vs HDD, RAM), de l‚Äôantivirus (exclusion du dossier des CSV), et de la taille des fichiers.

Si les fichiers sont √©normes, pense ‚Äúcolonne utile seulement‚Äù et √©vite les trims inutiles.

Si tu veux, dis-moi : taille des CSV, nombre de colonnes utiles, sur r√©seau ou local ‚Äî je te proposerai une version ‚Äúsur-mesure‚Äù (autant c√¥t√© M que c√¥t√© VBA).