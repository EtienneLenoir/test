    Sub Python3()

Dim wsh As Object
Set wsh = VBA.CreateObject("WScript.Shell")
Dim waitOnReturn As Boolean: waitOnReturn = True
Dim windowStyle As Integer: windowStyle = 1
Dim errorCode As Long

errorCode = wsh.Run(Chr(34) & "C:\Users\HP\Documents\Python Scripts" & "\EbayWebScraper.py" & Chr(34))

If errorCode = 0 Then
    MsgBox "Done! No error to report."
Else
    MsgBox "Program exited with error code " & errorCode & "."
End If

End Sub


Sub RunPython()

    Dim objShell As Object
    Dim PythonExe, PythonScript As String

    Set objShell = VBA.CreateObject("Wscript.Shell")

    PythonExe = """C:\your_path\Python\Python38\python.exe"""
    PythonScript = "C:\your_path\from_vba.py"

    objShell.Run PythonExe & PythonScript

End Sub

Sub RunPythonScriptWithArguments()
    Dim pythonExe As String
    Dim scriptPath As String
    Dim arguments As String
    Dim cmd As String

    pythonExe = "C:\Python39\python.exe";
    scriptPath = "C:\chemin\vers\votre\script.py";
    arguments = "arg1 arg2 arg3"; ' Arguments que vous souhaitez passer au script Python

    cmd = pythonExe & " " & scriptPath & " " & arguments;

    Shell cmd, vbNormalFocus;
End Sub


Dim ObjShell As Object
Dim PythonExe, PythonScript As String
 
Set ObjShell = VBA.CreateObject("Wscript.Shell")
PythonExe = """C:\Users\Laurent\Anaconda3\python.exe"""
PythonScript = ThisWorkbook.Path & "\Test_Py_to_VBA.py"
 
Dim command As String
Dim exec As Object
Dim output As Object
     
command = PythonExe & " " & PythonScript
Set exec = ObjShell.exec(command)
Set output = exec.StdOut
     
mavaleur = output.ReadLine
     
Range("B2") = mavaleur
 
 ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
 Option Explicit
Option Base 1
Option Compare Text

Public Const ADOBE_READER8_PATH As String = "C:\Program Files\Adobe\Reader 8.0\Reader\AcroRd32.exe"
Public Const ADOBE_READER9_PATH As String = "C:\Program Files\Adobe\Reader 9.0\Reader\AcroRd32.exe"
Private Const MODULE_NAME As String = "u_Utilities"

 Sub u_CREATE_PDF(ByVal TheSheet As Worksheet, _
                 ByVal SaveAsFilename As String, _
                 ByVal SaveToFolder As String, _
                 Optional ByVal ShowPDF As Boolean = True)
    
    On Error GoTo Handle_Err

'   Author       : Ken Puls (www.excelguru.ca)
'   Macro Purpose: Print to PDF file using PDFCreator
'   (Download from http://sourceforge.net/projects/pdfcreator/)
'   Designed for early bind, set reference to PDFCreator

    Dim pdfjob As Object    'PDFCreator.clsPDFCreator
    Dim sPDFName As String, sPDFPath As String, msg As String
        
    If TheSheet Is Nothing Then Set TheSheet = ActiveSheet
    TheSheet.Parent.Activate
    TheSheet.Activate
    
    '/// Change the output file name here! ///
    sPDFName = SaveAsFilename
    sPDFPath = SaveToFolder

    'Check if worksheet is empty and exit if so
'    If IsEmpty(ActiveSheet.UsedRange) Then
'        Err.Raise 5, MODULE_NAME & ".RatesSheetPDF", "No ratesheet to print!"
'    End If
    
    'Set pdfjob = New PDFCreator.clsPDFCreator
    Set pdfjob = CreateObject("PDFCreator.clsPDFCreator")
    With pdfjob
        If .cStart("/NoProcessingAtStartup") = False Then
            msg = "ERROR: Can't initialise PDFCreator!" & vbCrLf & Err.Description
            msg = msg & "PDF message: " & pdfjob.cerror.Description
            MsgBox msg, vbCritical
            
            Stop
            Exit Sub
        End If
        .cOption("UseAutosave") = 1
        .cOption("UseAutosaveDirectory") = 1
        .cOption("AutosaveDirectory") = sPDFPath
        .cOption("AutosaveFilename") = sPDFName
        .cOption("AutosaveFormat") = 0    ' 0 = PDF
        .cOption("Papersize") = "A4"
        .cClearCache
    End With

    'Print the document to PDF
    TheSheet.PrintOut from:=1, To:=10, Copies:=1, ActivePrinter:="PDFCreator"

    'Wait until the print job has entered the print queue
    Do Until pdfjob.cCountOfPrintjobs = 1
        DoEvents
    Loop
    pdfjob.cPrinterStop = False

    'Wait until PDF creator is finished then release the objects
    Do Until pdfjob.cCountOfPrintjobs = 0
        DoEvents
    Loop
    
    'Wait a bit longer for PDF Creator to finish - see http://www.excelguru.ca/node/87
    Application.Wait Now + TimeValue("0:0:2")
    
    pdfjob.cClose
    Set pdfjob = Nothing
    
    On Error Resume Next
    If ShowPDF Then Shell ADOBE_READER9_PATH & " """ & sPDFPath & "\" & sPDFName & """", vbNormalFocus
    If Err.Number = 53 Then
        If ShowPDF Then Shell ADOBE_READER8_PATH & " """ & sPDFPath & "\" & sPDFName & """", vbNormalFocus
    End If
    On Error GoTo Handle_Err
    
    Exit Sub

Handle_Err:
    MsgBox "Error in u_CREATE_PDF"
End Sub

''''''''''''''''''''''''''

Public Function u_GetEnvComputerName() As String
    Application.Volatile False
    Static computerName As String
    If Len(computerName) = 0 Then
        computerName = Environ("computername")
    End If
    u_GetEnvComputerName = computerName
End Function


'''''''''''''''''''''''
Function q_SQL_Select(ByVal SQL As String, _
                      Optional ByVal Connection_or_ConnectionString As Variant, _
                      Optional ByVal MaxRows As Long = -99) As Variant

'   Performs the SQL query on the database and returns the result in an array

    Application.Volatile False
    On Error GoTo Handle_Err
    
    Dim conn As ADODB.Connection, rs As ADODB.Recordset, r As Long, c As Long, NeedToCloseConnection As Boolean
    
    'Init
    If MaxRows > 0 Then SQL = "set rowcount " & MaxRows & vbCr & SQL
    
    'Open connection to database
    Select Case TypeName(Connection_or_ConnectionString)
        Case "String"           'User has provided a connection string
            Set conn = New ADODB.Connection
            conn.ConnectionString = Connection_or_ConnectionString
            conn.Open
            NeedToCloseConnection = True        'Since we opened it within this function, we also need to close it before we exit
        Case "Connection"
            Set conn = Connection_or_ConnectionString
            NeedToCloseConnection = False       'No need to close connection because we were given it
        Case Else   'Eg: "Missing" or "Error" or "Nothing"
            Set conn = New ADODB.Connection
            conn.ConnectionString = DEFAULT_DB_CONNECTION_STRING_READONLY
            conn.Open
            NeedToCloseConnection = True        'Since we opened it within this function, we also need to close it before we exit
    End Select
    
    'Get the data into recordset rs
    Set rs = New ADODB.Recordset
    rs.CursorLocation = adUseClient
    rs.Open SQL, conn, adOpenStatic
    
    'Transcribe rs into output
    If rs.RecordCount = 0 Then
        q_SQL_Select = ""
    Else
        ReDim OutputArray(rs.RecordCount, rs.Fields.Count)
        rs.MoveFirst
        For r = 1 To rs.RecordCount
            For c = 1 To rs.Fields.Count
                If IsNull(rs.Fields(c - 1).Value) Then
                    OutputArray(r, c) = ""
                Else
                    OutputArray(r, c) = rs.Fields(c - 1).Value
                End If
            Next
            rs.MoveNext
        Next
        q_SQL_Select = OutputArray
    
    End If
    
    'Close connection and rs
    If NeedToCloseConnection Then conn.Close
    Set rs = Nothing
    
    Exit Function

Handle_Err:
    q_SQL_Select = "q_SQL_SELECT: " & Err.Description

End Function

Function q_DATE_IsLastDayOfMonth(ByVal TheDate As Long) As Boolean
'   Returns true if TheDate is the last day of the month
    Application.Volatile False
    q_DATE_IsLastDayOfMonth = Month(TheDate) <> Month(TheDate + 1)
End Function


Function q_DATE_DaysInMonth(TheDate As Long) As Integer
'   Returns the number of days in the month of TheDate
    Application.Volatile False
    q_DATE_DaysInMonth = Day(DateSerial(Year(TheDate), Month(TheDate) + 1, 1) - 1)
End Function
'''''''''''''''''''''''''''''''''
Function q_ARRAY(ByVal p1, Optional ByVal p2, Optional ByVal p3, Optional ByVal p4, Optional ByVal p5, Optional ByVal p6, Optional ByVal p7, Optional ByVal p8, Optional ByVal p9, Optional ByVal p10, Optional ByVal p11, Optional ByVal p12) As Variant
'   This function is primarily to give spreadsheets the same function as VBA's array() function
'   Limit a dozen inputs

    Application.Volatile False
    
    If IsMissing(p2) Then
        q_ARRAY = Array(p1)
    ElseIf IsMissing(p3) Then
        q_ARRAY = Array(p1, p2)
    ElseIf IsMissing(p4) Then
        q_ARRAY = Array(p1, p2, p3)
    ElseIf IsMissing(p5) Then
        q_ARRAY = Array(p1, p2, p3, p4)
    ElseIf IsMissing(p6) Then
        q_ARRAY = Array(p1, p2, p3, p4, p5)
    ElseIf IsMissing(p7) Then
        q_ARRAY = Array(p1, p2, p3, p4, p5, p6)
    ElseIf IsMissing(p8) Then
        q_ARRAY = Array(p1, p2, p3, p4, p5, p6, p7)
    ElseIf IsMissing(p9) Then
        q_ARRAY = Array(p1, p2, p3, p4, p5, p6, p7, p8)
    ElseIf IsMissing(p10) Then
        q_ARRAY = Array(p1, p2, p3, p4, p5, p6, p7, p8, p9)
    ElseIf IsMissing(p11) Then
        q_ARRAY = Array(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)
    ElseIf IsMissing(p12) Then
        q_ARRAY = Array(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)
    Else
        q_ARRAY = Array(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)
    End If
        
End Function

'''''''''''''''''''''
Function q_ARRAY_AppendAcross(ByVal a, _
                              ByVal B, _
                              Optional ByVal FillValue) As Variant

'   Given 2-dimensional arrays A and B, this returns a new array which is large enough to
'   contain both A (on the left) and B (on the right).  Any spaces are filled with FillValue

    Application.Volatile False
    
    Dim r As Long, c As Long
    
    'Ensure both A and B are true 2 dimensional arrays
    a = q_Carr(a, "Down")
    B = q_Carr(B, "Down")
    
    Dim Arows: Arows = UBound(a)
    Dim Acols: Acols = UBound(a, 2)
    Dim Brows: Brows = UBound(B)
    Dim Bcols: Bcols = UBound(B, 2)
    
    If Arows = Brows Then
        
        'Since A and B have same number of rows, we can do this shortcut which saves calc time
        ReDim Preserve a(Arows, Acols + Bcols)
        For r = 1 To Brows
            For c = 1 To Bcols
                a(r, Acols + c) = B(r, c)
            Next
        Next
        q_ARRAY_AppendAcross = a
    
    Else
    
        ReDim OutputArray(Arows + Brows, Acols + Bcols)
        
        For r = 1 To Arows
            For c = 1 To Acols
                OutputArray(r, c) = a(r, c)
            Next
        Next
        
        If Not IsMissing(FillValue) Then
            For r = Arows + 1 To Arows + Brows
                For c = 1 To Acols
                    OutputArray(r, c) = FillValue
                Next
            Next
        End If
    
        For r = 1 To Brows
            For c = 1 To Bcols
                OutputArray(r, Acols + c) = B(r, c)
            Next
        Next
        
        If Not IsMissing(FillValue) Then
            For r = Brows + 1 To Arows + Brows
                For c = Acols + 1 To Acols + Bcols
                    OutputArray(r, c) = FillValue
                Next
            Next
        End If
        
        q_ARRAY_AppendAcross = OutputArray
    
    End If
End Function
'''''''''''''''''''''''''''''''''''''''''''
Function q_ARRAY_Flip(ByVal TheArray As Variant, _
                Optional ByVal FlipHorizontal As Boolean = False, _
                Optional ByVal FlipVertical As Boolean = False, _
                Optional ByVal FlipDiagonal_TopLeftBottomRight As Boolean = False, _
                Optional ByVal FlipDiagonal_BottomLeftTopRight As Boolean = False) As Variant

'   Given TheArray (2 dimensions) which can be an array or a range, this function flips it along
'   various axes as requested.  Note that diagonal flips can only be performed on square arrays.
'   This function is designed for 2 dimensional arrays and not vectors.  If you want to reverse
'   the elements in a vector, use q_ARRAY_ReverseOrder()


    Application.Volatile False
    
    Dim OutputArray As Variant, RR As Long, CC As Long, r As Long, c As Long
    
    TheArray = q_Carr(TheArray)
    OutputArray = TheArray
    RR = UBound(TheArray, 1)
    CC = UBound(TheArray, 2)
    
    If FlipHorizontal Then
        For r = 1 To RR
            For c = 1 To CC
                OutputArray(r, c) = TheArray(RR - r + 1, c)
            Next
        Next
        TheArray = OutputArray
    End If
    
    
    If FlipVertical Then
        For r = 1 To RR
            For c = 1 To CC
                OutputArray(r, c) = TheArray(r, CC - c + 1)
            Next
        Next
        TheArray = OutputArray
    End If

    If FlipDiagonal_TopLeftBottomRight Then
        If RR = CC Then
            For r = 1 To RR
                For c = 1 To CC
                    OutputArray(r, c) = TheArray(c, r)
                Next
            Next
        Else
            q_ARRAY_Flip = "Cannot diagonally flip a non-square array"
            Exit Function
        End If
        TheArray = OutputArray
    End If

    If FlipDiagonal_BottomLeftTopRight Then
        If RR = CC Then
            For r = 1 To RR
                For c = 1 To CC
                    OutputArray(r, c) = TheArray(CC - c + 1, RR - r + 1)
                Next
            Next
        Else
            q_ARRAY_Flip = "Cannot diagonally flip a non-square array"
            Exit Function
        End If
        TheArray = OutputArray
    End If

    q_ARRAY_Flip = OutputArray

End Function
''''''''''''''''
https://github.com/sdkn104/VBA-CSV

https://ws-garcia.github.io/VBA-CSV-interface/
https://github.com/ws-garcia/VBA-CSV-interface
https://github.com/PGS62/VBA-CSV
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

**Déterminer la fin d’un processus Shell**
```
Option Explicit 

Private Type STARTUPINFO 
cb As Long 
lpReserved As String 
lpDesktop As String 
lpTitle As String 
dwX As Long 
dwY As Long 
dwXSize As Long 
dwYSize As Long 
dwXCountChars As Long 
dwYCountChars As Long 
dwFillAttribute As Long 
dwFlags As Long 
wShowWindow As Integer 
cbReserved2 As Integer 
lpReserved2 As Long 
hStdInput As Long 
hStdOutput As Long 
hStdError As Long 
End Type 

Private Type PROCESS_INFORMATION 
hProcess As Long 
hThread As Long 
dwProcessID As Long 
dwThreadID As Long 
End Type 

Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal _ 
hHandle As Long, ByVal dwMilliseconds As Long) As Long 

Private Declare Function CreateProcessA Lib "kernel32" (ByVal _ 
lpApplicationName As Long, ByVal lpCommandLine As String, ByVal _ 
lpProcessAttributes As Long, ByVal lpThreadAttributes As Long, _ 
ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, _ 
ByVal lpEnvironment As Long, ByVal lpCurrentDirectory As Long, _ 
lpStartupInfo As STARTUPINFO, lpProcessInformation As _ 
PROCESS_INFORMATION) As Long 

Private Declare Function CloseHandle Lib "kernel32" (ByVal _ 
hObject As Long) As Long 

Private Const NORMAL_PRIORITY_CLASS = &H20& 
Private Const INFINITE = -1&
```	
Public Sub ExecCmd(cmdline As String) 
Dim proc As PROCESS_INFORMATION 
Dim start As STARTUPINFO 
Dim ReturnValue As Integer 

' Initialize the STARTUPINFO structure: 
start.cb = Len(start) 

' Start the shelled application: 
ReturnValue = CreateProcessA(0&, cmdline$, 0&, 0&, 1&, _ 
NORMAL_PRIORITY_CLASS, 0&, 0&, start, proc) 

' Wait for the shelled application to finish: 
Do 
ReturnValue = WaitForSingleObject(proc.hProcess, 0) 
DoEvents 
Loop Until ReturnValue <> 258 

ReturnValue = CloseHandle(proc.hProcess) 
End Sub

```
 On Error GoTo ErrorHandler
    Err.Raise CustomErrors.CustomErr1 'Raise a customer error using the Enum
    Exit Sub
    
ErrorHandler:
    Select Case Err.Number
    Case CustomErrors.CustomErr1:
        GoTo CustomErr1Handler
    Case CustomErrors.CustomErr2:
        GoTo CustomErr1Handler
    Case Else:
        GoTo OtherError
    End Select
 
CustomErr1Handler:
    Debug.Print "CustomErr1"
    Err.Clear
    Exit Sub
CustomErr2Handler:
    Debug.Print "CustomErr2"
    Err.Clear
    Exit Sub
OtherError:
    Debug.Print "Other error!, Error: " & Err.Number
    Err.Clear
    Exit Sub

```


```
Sub ZipFiles()
    Dim ShellApp As Object
    Dim FileNameZip As Variant
    Dim FileNames As Variant
    Dim i As Long, FileCount As Long

'   Get the file names
    FileNames = Application.GetOpenFilename _
        (FileFilter:="All Files (*.*),*.*", _
         FilterIndex:=1, _
         Title:="Select the files to ZIP", _
         MultiSelect:=True)

'   Exit if dialog box canceled
    If Not IsArray(FileNames) Then Exit Sub
   
    FileCount = UBound(FileNames)
    FileNameZip = Application.DefaultFilePath & "\compressed.zip"
    
    'Create empty Zip File with zip header
    Open FileNameZip For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
 
    Set ShellApp = CreateObject("Shell.Application")
    'Copy the files to the compressed folder
    For i = LBound(FileNames) To UBound(FileNames)
        DoEvents
        ShellApp.Namespace(FileNameZip).CopyHere FileNames(i)

        'Keep script waiting until Compressing is done
        On Error Resume Next
        Do Until ShellApp.Namespace(FileNameZip).items.Count = i
          DoEvents
          Application.Wait (Now + TimeValue("0:00:01"))
        Loop
        Application.StatusBar = "File " & i & " of " & UBound(FileNames)
    Next i
    
    Application.StatusBar = False
'   Prompt to view
    If MsgBox(FileCount & " files were zipped to:" & _
       vbNewLine & FileNameZip & vbNewLine & vbNewLine & _
       "Do you want to view the zip file?", vbQuestion + vbYesNo) = vbYes Then _
       Shell "Explorer.exe /e," & FileNameZip, vbNormalFocus
End Sub
```
```
Sub UnzipAFile()
 Dim ShellApp As Object
 Dim TargetFile
 Dim ZipFolder
' Target file & temp dir
 TargetFile = Application.GetOpenFilename _
 (FileFilter:="Zip Files (*.zip), *.zip")
 If TargetFile = False Then Exit Sub
 ZipFolder = Application.DefaultFilePath & "\Unzipped\"
' Create a temp folder
 On Error Resume Next
 RmDir ZipFolder
 MkDir ZipFolder
 On Error GoTo 0
' Copy the zipped files to the newly created folder
 Set ShellApp = CreateObject("Shell.Application")
 ShellApp.Namespace(ZipFolder).CopyHere _
 ShellApp.Namespace(TargetFile).items
 If MsgBox("The file was unzipped to:" & _
 vbNewLine & ZipFolder & vbNewLine & vbNewLine & _
 "View the folder?", vbQuestion + vbYesNo) = vbYes Then _
 Shell "Explorer.exe /e," & ZipFolder, vbNormalFocus
End Sub
```


```
Function FindFirstFile(ByRef SearchName As String) As String
    Dim oFSO    As Object
    Dim oFile   As Object
    Dim oFolder As Object
    Const str_path As String = "C:\Program Files\Microsoft Office\Office\Library"    '<<< fix this

    FindFirstFile = "file not created"
    Set oFSO = CreateObject("Scripting.FileSystemObject")
    Set oFolder = oFSO.GetFolder(str_path)
    For Each oFile In oFolder.Files
        If VBA.InStr(1, oFile.Name, SearchName, vbTextCompare) > 0 Then
           FindFirstFile = oFile.Name & " exists"
           Exit For   '<<< edited
        End If
    Next 'oFile

    Set oFile = Nothing
    Set oFolder = Nothing
    Set oFSO = Nothing
End Function
```


# Open Large CSV Fast
```
Option Base 1
Sub OpenLargeCSVFast()
Dim buf(1 To 16384) As Variant
Dim i As Long
'Change the file location and name here
Const strFilePath As String = "C:\temp\Sales.CSV"
Dim strRenamedPath As String
strRenamedPath = Split(strFilePath, ".")(0) & "txt"
With Application
.ScreenUpdating = False
.DisplayAlerts = False
End With
'Setting an array for FieldInfo to open CSV
For i = 1 To 16384
buf(i) = Array(i, 2)
Next
Name strFilePath As strRenamedPath
Workbooks.OpenText Filename:=strRenamedPath,
DataType:=xlDelimited, _
Comma:=True, FieldInfo:=buf
Erase buf
ActiveSheet.UsedRange.Copy ThisWorkbook.Sheets(1).Range("A1")
ActiveWorkbook.Close False
Kill strRenamedPath
With Application
.ScreenUpdating = True
.DisplayAlerts = True
End With
End Sub
```

# Export Range to CSV

```
Sub ExportARange()
    Dim RangeToExport As Range
    
    Set RangeToExport = ActiveWindow.RangeSelection
    If Application.CountA(RangeToExport) = 0 Then
        MsgBox "The selection is empty."
        Exit Sub
    End If
    
    Dim CSVFile As New CSVFileClass
    On Error Resume Next
    With CSVFile
        .ExportRange = RangeToExport
        .Export CSVFileName:=Application.DefaultFilePath & "\temp.csv"
        If Err <> 0 Then MsgBox "Cannot export" & Application.DefaultFilePath & "\temp.csv"
    End With
End Sub

Function DefaultFilePath()
    DefaultFilePath = Application.DefaultFilePath
End Function
```

## Rechercher un répertoire et obtenir son chemin d'accès

Placez la fonction suivante dans un module général, onglet Module et que vous nommerez "mod_RechercheRepertoire" par exemple.
**Remarque :**
Le chemin retourné, est celui qui mène au premier répertoire trouvé.
Si donc vous cherchez le répertoire "Test" dont il existe deux exemplaires, vous obtiendrez par exemple "C:\Niveau1\Test" et jamais "C:\Niveau1\Niveau2\Test".
```
Function fnSearchFolder(StartPath As String, FolderName As String)
    '//
    '//     Syntaxe :
    '//     Chemin = fnSearchFolder("C:\","MonRepertoire")
    '//     Chemin = fnSearchFolder("D:\Images","MonRepertoire")
    '//
    On Error GoTo Err_SearchFolder
    Dim boFound As Boolean
    Dim i As Integer, j As Integer, MaxRep As Integer
    Dim Path2Folder() As String
    Dim sFind As String
    Const vbDir As Integer = vbDirectory

    If Right(StartPath, 1) <> "/" Then StartPath = StartPath & "/"
    FolderName = Replace(FolderName, "/", "")
    i = 1: j = 0: MaxRep = 0: boFound = False
    ReDim Path2Folder(100)
    Path2Folder(0) = StartPath
    sFind = Dir(StartPath, vbDir)
    Do While (Path2Folder(j) <> "") And (boFound = False)
        Do While (sFind <> "") And (boFound = False)
            If sFind <> "." And sFind <> ".." Then
                If (GetAttr(Path2Folder(j) & sFind) And vbDir) = vbDir Then
                    If i > (MaxRep - 5) Then
                        MaxRep = i + 100
                        ReDim Preserve Path2Folder(MaxRep)
                    End If
                    Path2Folder(i) = Path2Folder(j) & sFind & "/"
                    If Right(Path2Folder(i), Len(FolderName) + 2) = _
                       ("/" & FolderName & "/") Then
                        fnSearchFolder = Path2Folder(i)
                        boFound = True
                    End If
                    i = i + 1
                End If
            End If
            sFind = Dir
        Loop
        j = j + 1
        sFind = Dir(Path2Folder(j), vbDir)
    Loop

Exit_SearchFolder:
    Exit Function
Err_SearchFolder:
    If Err.Number <> 52 Then
        MsgBox Err.Number & " " & Err.Description
    End If
    Resume Exit_SearchFolder
End Function
```


Sub ExcelFileSearch()
Dim srchExt As Variant, srchDir As Variant
Dim i As Long, j As Long, strName As String
Dim varArr(1 To 1048576, 1 To 3) As Variant
Dim strFileFullName As String
Dim ws As Worksheet
Dim fso As Object
Let srchExt = Application.InputBox("Please Enter File Extension",
"Info Request")
If srchExt = False And Not TypeName(srchExt) = "String" Then
Exit Sub
End If
Let srchDir = BrowseForFolderShell
If srchDir = False And Not TypeName(srchDir) = "String" Then
Exit Sub
End If
Application.ScreenUpdating = False
Set ws = ThisWorkbook.Worksheets.Add(Sheets(1))
On Error Resume Next
Application.DisplayAlerts = False
ThisWorkbook.Worksheets("FileSearch Results").Delete
Application.DisplayAlerts = True
On Error GoTo 0
ws.Name = "FileSearch Results"
Let strName = Dir$(srchDir & "\*" & srchExt)
Do While strName <> vbNullString
Let i = i + 1
Let strFileFullName = srchDir & strName
Let varArr(i, 1) = strFileFullName
Let varArr(i, 2) = FileLen(strFileFullName) \ 1024
Let varArr(i, 3) = FileDateTime(strFileFullName)
Let strName = Dir$()
Loop
Set fso = CreateObject("Scripting.FileSystemObject")
Call recurseSubFolders(fso.GetFolder(srchDir), varArr(), i,
CStr(srchExt))
Set fso = Nothing
ThisWorkbook.Windows(1).DisplayHeadings = False
With ws
If i > 0 Then
.Range("A2").Resize(i, UBound(varArr, 2)).Value = varArr
For j = 1 To i
.Hyperlinks.Add anchor:=.Cells(j + 1, 1),
Address:=varArr(j, 1)
Next
End If
.Range(.Cells(1, 4), .Cells(1,
.Columns.Count)).EntireColumn.Hidden = True
.Range(.Cells(.Rows.Count, 1).End(xlUp)(2), _
.Cells(.Rows.Count, 1)).EntireRow.Hidden = True
With .Range("A1:C1")
.Value = Array("Full Name", "Kilobytes", "Last Modified")
.Font.Underline = xlUnderlineStyleSingle
.EntireColumn.AutoFit
.HorizontalAlignment = xlCenter
End With
End With
Application.ScreenUpdating = True
End Sub
Private Sub recurseSubFolders(ByRef Folder As Object, _
ByRef varArr() As Variant, _
ByRef i As Long, _
ByRef srchExt As String)
Dim SubFolder As Object
Dim strName As String, strFileFullName As String
For Each SubFolder In Folder.SubFolders
Let strName = Dir$(SubFolder.Path & "\*" & srchExt)
Do While strName <> vbNullString
Let i = i + 1
Let strFileFullName = SubFolder.Path & "\" & strName
Let varArr(i, 1) = strFileFullName
Let varArr(i, 2) = FileLen(strFileFullName) \ 1024
Let varArr(i, 3) = FileDateTime(strFileFullName)
Let strName = Dir$()
Loop
If i > 1048576 Then Exit Sub
Call recurseSubFolders(SubFolder, varArr(), i, srchExt)
Next
End Sub
Private Function BrowseForFolderShell() As Variant
Dim objShell As Object, objFolder As Object
Set objShell = CreateObject("Shell.Application")
Set objFolder = objShell.BrowseForFolder(0, "Please select a folder",
0, "C:\")
If Not objFolder Is Nothing Then
On Error Resume Next
If IsError(objFolder.Items.Item.Path) Then
BrowseForFolderShell = CStr(objFolder)
Else
On Error GoTo 0
If Len(objFolder.Items.Item.Path) > 3 Then
BrowseForFolderShell = objFolder.Items.Item.Path & _
Application.PathSeparator
Else
BrowseForFolderShell = objFolder.Items.Item.Path
End If
End If
Else
BrowseForFolderShell = False
End If
Set objFolder = Nothing: Set objShell = Nothing
End Function



```vb
'---------------------------------------------------------------------------------------
' Procedure : Crypter
' Purpose   : Crypter la chaîne chaîneACrypter en fonction d'une clef et de la méthode
'               de Vigenère
'---------------------------------------------------------------------------------------
'
Function Crypter(ByVal chaîneACrypter As String)
    Dim sLettres    As String
    Dim lCompteur   As Long
    Dim lLongueur   As Long
    Dim lBoucle     As Long
    
    'Définition des constantes utiles pour la fonction (Clé et nombre d'itérations de la fonction maximum)
    Const CLEF              As String = "nbvfdszé""'(-è_ijhgfcKLKjhgyuilM^+)àçiu-('32azsDRtvBhujkoç_è6tre""zsXWqazerfcx<;:<?"
    Const NBROTATIONSMAX    As Long = 13
    
    'Définition de la longueur de la chaîne à crypter et de la chaîne de résultat
    lLongueur = Len(chaîneACrypter)
    sLettres = String(lLongueur, Chr(0))
    
    'Boucler en fonction du nombre de rotations attendues
    For lBoucle = 1 To NBROTATIONSMAX
        'boucler pour chaque caractère de la chaîne initiale
        For lCompteur = 1 To lLongueur
            'Remplacer le caractère de la chaîne à crypter par le caractère correspondant à
            '   le reste de
            '       la valeur ascii du caractère à crypter
            '       plus
            '       la valeur ascii du caractère correspondant dans la clé, multiplié par la longueur de la clé
            '   quand on le divise par 256
            Mid(sLettres, lCompteur, 1) = Chr((Asc(Mid(chaîneACrypter, lCompteur, 1)) + _
                    (Asc(Mid(CLEF, (lCompteur Mod Len(CLEF)) + 1, 1)) * lLongueur)) Mod 256)
        'recommencer
        Next
        'réaffecter la chaîne à crypter par le résultat trouvé pour pouvoir recommencer une itération
        chaîneACrypter = sLettres
    'Nouvelle itération
    Next
    'Renvoyer le résultat final
    Crypter = sLettres
End Function
```



```vb
'---------------------------------------------------------------------------------------
' Procedure : Crypter
' Purpose   : deCrypter la chaîne chaîneACrypter en fonction d'une clef et de la méthode
'               de Vigenère
'---------------------------------------------------------------------------------------
'
Function deCrypter(ByVal chaîneAdeCrypter As String)

    Dim sLettres    As String
    Dim lCompteur   As Long
    Dim lLongueur   As Long
    Dim lBoucle     As Long
    
    'Définition des constantes utiles pour la fonction (Clé et nombre d'itérations de la fonction maximum)
    Const CLEF              As String = "nbvfdszé""'(-è_ijhgfcKLKjhgyuilM^+)àçiu-('32azsDRtvBhujkoç_è6tre""zsXWqazerfcx<;:<?"
    Const NBROTATIONSMAX    As Long = 13
    
    'Définition de la longueur de la chaîne à crypter et de la chaîne de résultat
    lLongueur = Len(chaîneAdeCrypter)
    sLettres = String(lLongueur, Chr(0))
 
    'Boucler en fonction du nombre de rotations attendues
    For lBoucle = 1 To NBROTATIONSMAX
        'boucler pour chaque caractère de la chaîne initiale
        For lCompteur = 1 To lLongueur
            'Remplacer le caractère de la chaîne à crypter par le caractère correspondant à
            '   le reste de
            '       la valeur ascii du caractère à crypter
            '       plus
            '       la valeur ascii du caractère correspondant dans la clé, multiplié par la longueur de la clé
            '   quand on le divise par 256
            Dim reste As Integer
            reste = Asc(Mid(chaîneAdeCrypter, lCompteur, 1))
            
            Mid(sLettres, lCompteur, 1) = Chr((((Asc(Mid(chaîneAdeCrypter, lCompteur, 1)) - _
                    (Asc(Mid(CLEF, (lCompteur Mod Len(CLEF)) + 1, 1)) * lLongueur)) Mod 256) + 256) Mod 256)
        'recommencer
        Next
        'réaffecter la chaîne à crypter par le résultat trouvé pour pouvoir recommencer une itération
        chaîneAdeCrypter = sLettres
    'Nouvelle itération
    Next
    'Renvoyer le résultat final
    deCrypter = sLettres
End Function
```



[TOC]


# ReadTxtLines Fast technic

```
Read Entire TXT to Memory and Parse
Submitted by Suat Mehmet Ozgur of Istanbul, Turkey. Suat develops applications in Excel, Access, and Visual Basic.
This sample takes a different approach to reading a text file. Instead of reading one record at a time, the macro loads the entire text file into memory in a single string variable. The macro then parses the string into individual records. The advantage of this method is that you access the file on disk only one time. All
subsequent processing occurs in memory and is very fast.

Sub ReadTxtLines()
'No need to install Scripting Runtime library since we used late
binding
Dim sht As Worksheet
Dim fso As Object
Dim fil As Object
Dim txt As Object
Dim strtxt As String
Dim tmpLoc As Long
'Working on active sheet
Set sht = ActiveSheet
'Clear data in the sheet
sht.UsedRange.ClearContents
'File system object that we need to manage files
Set fso = CreateObject("Scripting.FileSystemObject")
'File that we like to open and read
Set fil = fso.GetFile("c:\temp\Sales.txt")
'Opening file as a TextStream
Set txt = fil.OpenAsTextStream(1)
'Reading entire file into a string variable at once
strtxt = txt.ReadAll
'Close textstream and free the file. We don't need it anymore.
txt.Close
'Find the first placement of new line char
tmpLoc = InStr(1, strtxt, vbCrLf)
'Loop until no more new line
Do Until tmpLoc = 0
'Use A column and next empty cell to write the text file line
sht.Cells(sht.Rows.Count, 1).End(xlUp).Offset(1).Value = _
Left(strtxt, tmpLoc - 1)
'Remove the parsed line from the variable where we stored the
entire file
strtxt = Right(strtxt, Len(strtxt) - tmpLoc - 1)
'Find the next placement of new line char
tmpLoc = InStr(1, strtxt, vbCrLf)
Loop
'Last line that has data but no new line char
sht.Cells(sht.Rows.Count, 1).End(xlUp).Offset(1).Value = strtxt
'It will be already released by the ending of this procedure but
' as a good habit, set the object as nothing.
Set fso = Nothing
End Sub
```

# Text file 

```
Sub ReadTextFile()
    Dim objFs As Object
    Dim objFile As Object
    Dim strContent As String
    Dim strFileName As String

    strFileName = "C:\Windows\System.ini"
    Set objFs = CreateObject("Scripting.FileSystemObject")
    Set objFile = objFs.OpenTextFile(strFileName)
    Do While Not objFile.AtEndOfStream
        strContent = strContent & objFile.ReadLine & vbCrLf
    Loop

    objFile.Close
    Set objFile = Nothing
    ActiveWorkbook.Sheets(3).Select
    Range("A1").Formula = strContent
    Columns("A:A").Select
    With Selection
        .ColumnWidth = 62.43
        .Rows.AutoFit
    End With
End Sub

Sub CreateFile_Method1()
    Dim objFs As Object
    Dim objFile As Object
    
    Set objFs = CreateObject("Scripting.FileSystemObject")
    Set objFile = objFs.CreateTextFile("C:\Phones.txt", True)

    objFile.WriteLine ("Margaret Kubiak: 212-338-8778")
    objFile.WriteBlankLines (2)
    objFile.WriteLine ("Robert Prochot: 202-988-2331")
    objFile.Close
End Sub


Sub CreateFile_Method2()
    Dim objFs As Object
    Dim objFile As Object
    
    Const ForWriting = 2
        
    Set objFs = CreateObject("Scripting.FileSystemObject")
    Set objFile = objFs.OpenTextFile("C:\Shopping.txt", _
        ForWriting, True)
    
    objFile.WriteLine ("Bread")
    objFile.WriteLine ("Milk")
    objFile.WriteLine ("Strawberries")
    objFile.Close
End Sub


Sub CreateFile_Method3()
    Dim objFs As Object
    Dim objFile As Object
    Dim objText As Object
    Const ForWriting = 2
    Const ForReading = 1
    
    Set objFs = CreateObject("Scripting.FileSystemObject")
    objFs.CreateTextFile "New.txt"
    Set objFile = objFs.GetFile("New.txt")
    Set objText = objFile.OpenAsTextStream(ForWriting, _
        TristateUseDefault)
    
    objText.Write "Wedding Invitation"
    objText.Close
    Set objText = objFile.OpenAsTextStream(ForReading, _
        TristateUseDefault)
    MsgBox objText.ReadLine
    objText.Close
End Sub
```


# Import data from text file in excel

The code in the following example reads a text file and then places each line of data in a  single cell (beginning with the active cell):
```
Sub ImportData()
 Open "c:\data\textfile.txt" For Input As #1
 r = 0
 Do Until EOF(1)
 Line Input #1, data
 ActiveCell.Offset(r, 0) = data
 r = r + 1
 Loop
 Close #1
End Sub
'''''''''''''''''''''''''''''''
BEST , FAST



Sub ReadTxtLines()
'No need to install Scripting Runtime library since we used late
binding
Dim sht As Worksheet
Dim fso As Object
Dim fil As Object
Dim txt As Object
Dim strtxt As String
Dim tmpLoc As Long
'Working on active sheet
Set sht = ActiveSheet
'Clear data in the sheet
sht.UsedRange.ClearContents
'File system object that we need to manage files
Set fso = CreateObject("Scripting.FileSystemObject")
'File that we like to open and read
Set fil = fso.GetFile("c:\temp\Sales.txt")
'Opening file as a TextStream
Set txt = fil.OpenAsTextStream(1)
'Reading entire file into a string variable at once
strtxt = txt.ReadAll
'Close textstream and free the file. We don't need it anymore.
txt.Close
'Find the first placement of new line char
tmpLoc = InStr(1, strtxt, vbCrLf)
'Loop until no more new line
Do Until tmpLoc = 0
'Use A column and next empty cell to write the text file line
sht.Cells(sht.Rows.Count, 1).End(xlUp).Offset(1).Value = _
Left(strtxt, tmpLoc - 1)
'Remove the parsed line from the variable where we stored the
entire file
strtxt = Right(strtxt, Len(strtxt) - tmpLoc - 1)
'Find the next placement of new line char
tmpLoc = InStr(1, strtxt, vbCrLf)
Loop
'Last line that has data but no new line char
sht.Cells(sht.Rows.Count, 1).End(xlUp).Offset(1).Value = strtxt
'It will be already released by the ending of this procedure but
' as a good habit, set the object as nothing.
Set fso = Nothing
End Sub
```


```
' Procedure : ImportTextFile
' Purpose   : Import data from a txt or csv file and paste it in the active cell
' Example   : ImportTextFile("C:\Example.txt", ";")

Public Sub ImportTextFile(FName As String, Optional Separator As String = vbTab)

    Dim RowNdx As Integer
    Dim ColNdx As Integer
    Dim TempVal As Variant
    Dim WholeLine As String
    Dim pos As Integer
    Dim NextPos As Integer
    Dim SaveColNdx As Integer
    
    Application.ScreenUpdating = False
    On Error GoTo EndMacro:
    
    SaveColNdx = ActiveCell.Column
    RowNdx = ActiveCell.Row
    
    Open FName For Input Access Read As #1
    
    While Not EOF(1)
        Line Input #1, WholeLine
        If Right(WholeLine, 1) <> Separator Then
            WholeLine = WholeLine & Separator
        End If
        ColNdx = SaveColNdx
        pos = 1
        NextPos = InStr(pos, WholeLine, Separator)
        While NextPos >= 1
            TempVal = Mid(WholeLine, pos, NextPos - pos)
            Cells(RowNdx, ColNdx).Value = TempVal
            pos = NextPos + 1
            ColNdx = ColNdx + 1
            NextPos = InStr(pos, WholeLine, Separator)
        Wend
        RowNdx = RowNdx + 1
    Wend
    
EndMacro:
    On Error GoTo 0
    Application.ScreenUpdating = True
    Close #1
```

##  Batch Process

Va ouvrir 3 fichiers text01,text02,text03, va les lire et les copier dans un fichiel excel text01 etc.
```
Sub BatchProcess()
    Dim FileSpec As String
    Dim i As Integer
    Dim FileName As String
    Dim FileList() As String
    Dim FoundFiles As Integer

'   Specify path and file spec
    FileSpec = ThisWorkbook.Path & "\" & "text??.txt"
    FileName = Dir(FileSpec)
    
'   Was a file found?
    If FileName <> "" Then
        FoundFiles = 1
        ReDim Preserve FileList(1 To FoundFiles)
        FileList(FoundFiles) = FileName
    Else
        MsgBox "No files were found that match " & FileSpec
        Exit Sub
    End If
    
'   Get other filenames
    Do
        FileName = Dir
        If FileName = "" Then Exit Do
        FoundFiles = FoundFiles + 1
        ReDim Preserve FileList(1 To FoundFiles)
        FileList(FoundFiles) = FileName & "*"
    Loop

'   Loop through the files and process them
    For i = 1 To FoundFiles
        Call ProcessFiles(FileList(i))
    Next i
End Sub


Sub ProcessFiles(FileName As String)
'   Import the file
    Workbooks.OpenText FileName:=ThisWorkbook.Path & "\" & FileName, _
        Origin:=xlWindows, _
        StartRow:=1, _
        DataType:=xlFixedWidth, _
        FieldInfo:= _
        Array(Array(0, 1), Array(3, 1), Array(12, 1))
'   Enter summary formulas
    Range("D1").Value = "A"
    Range("D2").Value = "B"
    Range("D3").Value = "C"
    Range("E1:E3").Formula = "=COUNTIF(B:B,D1)"
    Range("F1:F3").Formula = "=SUMIF(B:B,D1,C:C)"
End Sub
```

# Import / export 

```
Sub ImportData()
Open"c:\data\textfile.txt" For Input As #1
r = 0
Do Until EOF(1)
Line Input #1, data
ActiveCell.Offset(r, 0) = data
r = r + 1
Loop
Close #1
End Sub


Sub ExportRange()
Dim Filename As String
Dim NumRows As Long, NumCols As Integer
Dim r As Long, c As Integer
Dim Data
Dim ExpRng As Range
Set ExpRng = Selection
NumCols = ExpRng.Columns.Count NumRows = ExpRng.Rows.Count
Filename = Application.DefaultFilePath &"\textfile.csv"
Open Filename For Output As #1
For r = 1 To NumRows
For c = 1 To NumCols
Data = ExpRng.Cells(r, c).Value
If IsNumeric(Data) Then Data = Val(Data)
If IsEmpty(ExpRng.Cells(r, c)) Then Data =""
If c <> NumCols Then
Write #1, Data;
Else
Write #1, Data
End If
Next c
Next r
Close #1
End Sub




Sub ImportRange()
Dim ImpRng As Range
Dim Filename As String
Dim r As Long, c As Integer
Dim txt As String, Char As String * 1
Dim Data Dim i As Integer
Set ImpRng = ActiveCell
On Error Resume Next
Filename = Application.DefaultFilePath &"\textfile.csv"
Open Filename For Input As #1
If Err <> 0 Then
MsgBox"Not found:" & Filename, vbCritical,"ERROR"
Exit Sub
End If
r = 0
c = 0
txt =""
Application.ScreenUpdating = False
Do Until EOF(1)
Line Input #1, Data
For i = 1 To Len(Data)
Char = Mid(Data, i, 1)
If Char ="," Then 'comma
ActiveCell.Offset(r, c) = txt
c = c + 1
txt =""
ElseIf i = Len(Data) Then 'end of line
If Char <> Chr(34) Then txt = txt & Char
ActiveCell.Offset(r, c) = txt
txt =""
ElseIf Char <> Chr(34) Then
txt = txt & Char
End If
Next i
c = 0
r = r + 1
Loop
Close #1
Application.ScreenUpdating = True
End Sub
```



```vb
' Purpose   : Export data (selection or entire worksheet) to a txt or csv file using specified separator
' Example   : ExportToTextFile("C:\Example.csv", vbTab, False)
'---------------------------------------------------------------------------------------
Public Sub ExportToTextFile(FName As String, Optional Separator As String = vbTab, Optional SelectionOnly As Boolean = False)

    Dim WholeLine As String
    Dim FNum As Integer
    Dim RowNdx As Long
    Dim ColNdx As Integer
    Dim StartRow As Long
    Dim EndRow As Long
    Dim StartCol As Integer
    Dim EndCol As Integer
    Dim CellValue As String
    
    Application.ScreenUpdating = False
    On Error GoTo EndMacro:
    FNum = FreeFile
    
    If SelectionOnly = True Then
        With Selection
            StartRow = .Cells(1).Row
            StartCol = .Cells(1).Column
            EndRow = .Cells(.Cells.Count).Row
            EndCol = .Cells(.Cells.Count).Column
        End With
    Else
        With ActiveSheet.UsedRange
            StartRow = .Cells(1).Row
            StartCol = .Cells(1).Column
            EndRow = .Cells(.Cells.Count).Row
            EndCol = .Cells(.Cells.Count).Column
        End With
    End If
    
    Open FName For Output Access Write As #FNum
    
    For RowNdx = StartRow To EndRow
        WholeLine = ""
        For ColNdx = StartCol To EndCol
            If Cells(RowNdx, ColNdx).Value = "" Then
                CellValue = Chr(34) & Chr(34)
            Else
               CellValue = Cells(RowNdx, ColNdx).Text
            End If
            WholeLine = WholeLine & CellValue & Separator
        Next ColNdx
        WholeLine = Left(WholeLine, Len(WholeLine) - Len(Separator))
        Print #FNum, WholeLine
    Next RowNdx
    
EndMacro:
    On Error GoTo 0
    Application.ScreenUpdating = True
    Close #FNum

End Sub
````
# Replace text in a text file

The macros below can be used to replace text in a text file, e.g. when you want to change a column separator in a text file before you import it into an Excel worksheet or after you export a worksheet to a text file. 
```
Sub ReplaceTextInFile(SourceFile As String, _
    sText As String, rText As String)
Dim TargetFile As String, tLine As String, tString As String
Dim p As Integer, i As Long, F1 As Integer, F2 As Integer
    TargetFile = "RESULT.TMP"
    If Dir(SourceFile) = "" Then Exit Sub
    If Dir(TargetFile) <> "" Then
        On Error Resume Next
        Kill TargetFile
        On Error GoTo 0
        If Dir(TargetFile) <> "" Then
            MsgBox TargetFile & _
                " already open, close and delete / rename the file and try again.", _
                vbCritical
            Exit Sub
        End If
    End If
    F1 = FreeFile
    Open SourceFile For Input As F1
    F2 = FreeFile
    Open TargetFile For Output As F2
    i = 1 ' line counter
    Application.StatusBar = "Reading data from " & _
        TargetFile & " ..."
    While Not EOF(F1)
        If i Mod 100 = 0 Then Application.StatusBar = _
            "Reading line #" & i & " in " & _
            TargetFile & " ..."
        Line Input #F1, tLine
        If sText <> "" Then
            ReplaceTextInString tLine, sText, rText
        End If
        Print #F2, tLine
        i = i + 1
    Wend
    Application.StatusBar = "Closing files ..."
    Close F1
    Close F2
    Kill SourceFile ' delete original file
    Name TargetFile As SourceFile ' rename temporary file
    Application.StatusBar = False
End Sub

Private Sub ReplaceTextInString(SourceString As String, _
    SearchString As String, ReplaceString As String)
Dim p As Integer, NewString As String
    Do
        p = InStr(p + 1, UCase(SourceString), UCase(SearchString))
        If p > 0 Then ' replace SearchString with ReplaceString
            NewString = ""
            If p > 1 Then NewString = Mid(SourceString, 1, p - 1)
            NewString = NewString + ReplaceString
            NewString = NewString + Mid(SourceString, _
                p + Len(SearchString), Len(SourceString))
            p = p + Len(ReplaceString) - 1
            SourceString = NewString
        End If
        If p >= Len(NewString) Then p = 0
    Loop Until p = 0
End Sub

Sub TestReplaceTextInFile()
    ReplaceTextInFile ThisWorkbook.Path & _
        "ReplaceInTextFile.txt", "|", ";"
    ' replaces all pipe-characters (|) with semicolons (;) 
End Sub
```

# Extract element

```
Function EXTRACTELEMENT(txt, n, Separator) As String
'   Returns the nth element of a text string, where the
'   elements are separated by a specified separator character
    Dim AllElements As Variant
    AllElements = Split(txt, Separator)
    EXTRACTELEMENT = AllElements(n - 1)
End Function

Function EXTRACTELEMENT2(txt, n, Separator) As String
'   Returns the nth element of a text string, where the
'   elements are separated by a specified separator character

    Dim Txt1 As String, TempElement As String
    Dim ElementCount As Integer, i As Integer
    
    Txt1 = txt
'   If space separator, remove excess spaces
    If Separator = Chr(32) Then Txt1 = Application.Trim(Txt1)
    
'   Add a separator to the end of the string
    If Right(Txt1, Len(Txt1)) <> Separator Then _
        Txt1 = Txt1 & Separator
    
'   Initialize
    ElementCount = 0
    TempElement = ""
    
'   Extract each element
    For i = 1 To Len(Txt1)
        If Mid(Txt1, i, 1) = Separator Then
            ElementCount = ElementCount + 1
            If ElementCount = n Then
'               Found it, so exit
                EXTRACTELEMENT2 = TempElement
                Exit Function
            Else
                TempElement = ""
            End If
        Else
            TempElement = TempElement & Mid(Txt1, i, 1)
        End If
    Next i
    EXTRACTELEMENT2 = ""
End Function
```

# File access with Microsoft Scripting Runtime 

```
Sub WriteToTextFile()
Dim fs As Scripting.FileSystemObject, f As Scripting.TextStream
Dim l As Long
    Set fs = New FileSystemObject
    Set f = fs.OpenTextFile("C:\FolderName\TextFileName.txt", _
        ForWriting, True)
    With f
        For l = 1 To 100
            .WriteLine "This is line number " & l
        Next l
        .Close
    End With
    Set f = Nothing
    Set fs = Nothing
End Sub

Sub AppendToTextFile()
Dim fs As Scripting.FileSystemObject, f As Scripting.TextStream
Dim l As Long
    Set fs = New FileSystemObject
    Set f = fs.OpenTextFile("C:\FolderName\TextFileName.txt", _
        ForAppending, True)
    With f
        For l = 1 To 100
            .WriteLine "Added line number " & l
        Next l
        .Close
    End With
    Set f = Nothing
    Set fs = Nothing
End Sub

Sub ReadFromTextFile()
Dim fs As Scripting.FileSystemObject, f As Scripting.TextStream
Dim l As Long
    Set fs = New FileSystemObject
    Set f = fs.OpenTextFile("C:\FolderName\TextFileName.txt", _
        ForReading, False)
    With f
        l = 0
        While Not .AtEndOfStream
            l = l + 1
            Cells(l, 5).Formula = .ReadLine
        Wend
        .Close
    End With
    Set f = Nothing
    Set fs = Nothing
End Sub
```




## Générer fichier TXT

Générer ligne par ligne un fichier texte (.txt) avec entêtes
```
Sub GenerateTXT(strSource As String, _
                Optional strPath As String = "", _
                Optional blnAdd As Boolean = False)
    On Error GoTo errGenerate
    '/
    '/ Générer ligne par ligne un fichier .txt
    '/ avec les noms de champs comme en-têtes
    '/ Si strPath est omis:
    '/   la destination sera le même répertoire que la base
    '/ Si blnAdd est False ou omis:
    '/   un nouveau fichier sera créé, sinon ajouter
    '/
    '/ Syntaxe:  Call GenerateTXT("LaTableouLaRequete", "C:\Mes Documents", True)
    '/      ou   Call GenerateTXT("LaTableouLaRequete", , True)
    '/      ou   Call GenerateTXT("LaTableouLaRequete")
    '/
    Const Separ = vbTab    'séparateur
    Const IdVal = Null    'délimiteur
    Dim Dbs As DAO.Database
    Dim Rst As DAO.Recordset
    Dim Fld As DAO.Field
    Dim strFile As String
    Dim StrHeadFile As String
    Dim TxtLine As String
    Dim Fichier As Integer, i As Integer
    If strPath = "" Then
        strPath = CurrentProject.Path
    End If
    strFile = strPath & "" & strSource & "_" & DCount("*", strSource) & ".txt"
    Set Dbs = CurrentDb
    Set Rst = Dbs.OpenRecordset(strSource)
    Fichier = FreeFile()
    If blnAdd = False Then
        'Créer un nouveau fichier avec en-tête
        Open strFile For Output As #Fichier
        'Lire le nom des champs
        For i = 0 To (Rst.Fields.Count - 1)
            StrHeadFile = StrHeadFile & IdVal & Rst.Fields(i).Name & IdVal & Separ
        Next i
        Print #Fichier, Left(StrHeadFile, Len(StrHeadFile) - Len(Separ))
    Else
        'Ajouter au fichier existant
        Open strFile For Append As #Fichier
    End If
    'Ecriture des lignes
    While Not Rst.EOF
        For Each Fld In Rst.Fields
            TxtLine = TxtLine & IdVal & Fld.Value & IdVal & Separ
        Next Fld
        TxtLine = Left(TxtLine, Len(TxtLine) - Len(Separ))
        Print #Fichier, TxtLine
        Rst.MoveNext
        TxtLine = ""
    Wend
    MsgBox "Fichier " & strFile & " créé.", vbOKOnly, ""
exitGenerate:
    Close #Fichier
    Rst.Close
    Dbs.Close
    Set Rst = Nothing
    Set Dbs = Nothing
    Exit Sub
errGenerate:
    MsgBox Err.Number & " " & Err.Description
    On Error Resume Next
    Resume exitGenerate
End Sub
```

 ## Importer ligne par ligne un fichier texte (.txt)
 
 Lecture de chaque ligne d'un fichier texte et importation dans un champ d'une table.
```
Sub ImportTXT()
    Dim txtLine As String
    Dim LeFichier As String
    Dim dbs As DAO.Database
    Dim rst As DAO.Recordset
    Dim F As Integer
    LeFichier = "c:\cheminfichier.txt"
    Set dbs = CurrentDb
    Set rst = dbs.OpenRecordset("LaTable", dbOpenDynaset)
    F = FreeFile
    Open LeFichier For Input As #F
    Line Input #F, txtLine
    Do While Not EOF(F)
        Line Input #F, txtLine
        With rst
            .AddNew
            .Fields("LeChamp").Value = txtLine
            .Update
        End With
    Loop
    Close #F
    rst.Close
    Set dbs = Nothing
    Set rst = Nothing
End Sub
```



Error Code Error Description
3 Return without GoSub
5 Invalid procedure call 
6 Overflow 
7 Out of memory 
9 Subscript out of range 
10 This array is fixed or temporarily locked 
11 Division by 0 
13 Type mismatch 
14 Out of string space 
16 Expression too complex 
17 Can’t perform requested operation 
18 User interruption (Ctrl + Break) occurred 
20 Resume without error 
28 Out of stack space 
Error Code Error Description
35 Sub, Function, or Property not defined 
47 Too many code resource or DLL application clients 
48 Error in loading code resource or DLL 
49 Bad code resource or DLL calling convention 
51 Internal error 
52 Bad filename or number 
53 File not found 
54 Bad file mode 
55 File already open 
57 Device I/O error 
58 File already exists 
59 Bad record length 
61 Disk full 
62 Input past end of file 
63 Bad record number 
67 Too many files 
68 Device unavailable 
70 Permission denied 
71 Disk not ready 
74 Can’t rename with different drive 
75 Path/file access error 
76 Path not found 
91 Object variable or With block variable not set 
92 For loop not initialized 
93 Invalid pattern string 
94 Invalid use of Null
97 Can’t call Friend procedure on an object that is not an instance of the
defining class 
98 A property or method call cannot include a reference to a private
object, either as an argument or as a return value 
298 System resource or DLL could not be loaded
Error Code Error Description
320 Can’t use character device names in specified filenames 
321 Invalid file format 
322 Can’t create necessary temporary file 
325 Invalid format in resource file 
327 Data value named not found 
328 Illegal parameter; can’t write arrays 
335 Could not access system registry 
336 Component not correctly registered 
337 Component not found 
338 Component did not run correctly 
360 Object already loaded 
361 Can’t load or unload this object 
363 Control specified not found 
364 Object was unloaded 
365 Unable to unload within this context 
368 The specified file is out of date; this program requires a later version 
371 The specified object can’t be used as an owner form for Show
380 Invalid property value 
381 Invalid property-array index 
382 Property Set can’t be executed at runtime 
383 Property Set can’t be used with a read-only property 
385 Need property-array index 
387 Property Set not permitted 
393 Property Get can’t be executed at runtime 
394 Property Get can’t be executed on write-only property 
400 Form already displayed; can’t show modally 
402 Code must close topmost modal form first 
419 Permission to use object denied 
422 Property not found 
423 Property or method not found
Error Code Error Description
424 Object required 
425 Invalid object use 
429 Component can’t create object or return reference to this object 
430 Class doesn’t support Automation 
432 File name or class name not found during Automation operation 
438 Object doesn’t support this property or method 
440 Automation error 
442 Connection to type library or object library for remote process has
been lost 
443 Automation object doesn’t have a default value 
445 Object doesn’t support this action 
446 Object doesn’t support named arguments 
447 Object doesn’t support current locale setting 
448 Named argument not found 
449 Argument not optional or invalid property assignment 
450 Wrong number of arguments or invalid property assignment 
451 Object not a collection 
452 Invalid ordinal 
453 Specified code resource not found 
454 Code resource not found 
455 Code resource lock error 
457 This key is already associated with an element of this collection 
458 Variable uses a type not supported in Visual Basic 
459 This component doesn’t support the set of events 
460 Invalid Clipboard format 
461 Method or data member not found 
462 The remote server machine does not exist or is unavailable 
463 Class not registered on local machine 
480 Can’t create AutoRedraw image 
481 Invalid picture 
482 Printer error
Error Code Error Description
483 Printer driver does not support specified property 
484 Problem getting printer information from the system; make sure printer
is set up correctly 
485 Invalid picture type 
486 Can’t print form image to this type of printer 
520 Can’t empty Clipboard 
521 Can’t open Clipboard 
735 Can’t save file to TEMP directory 
744 Search text not found 
746 Replacements too long 
31001 Out of memory 
31004 No object 
31018 Class is not set 
31027 Unable to activate object 
31032 Unable to create embedded object 
31036 Error saving to file 
31037 Error loading from file


# best logging
```vb
Attribute VB_Name = "Logger"

'---------------------------------------------------------------------------------------
' Module    : Logger
' Author    : Patrick Rye
' Date      : 7/22/2015
' Version	: 1.1.0
' Purpose   : Holds a procedure which will write stuff to a log.
'---------------------------------------------------------------------------------------
Option Explicit
'   ----------------------------------------------------------------------------
Private Const gBlLogAction As Boolean = True 'Whether all actions should be logged or not
Private Const strBaseLogFileName As String = "log.txt" 'The base name of the file
Private Const gBlAppendDateToLog As Boolean = True 'Whether the date should be added to the front of the log file or not.
Private Const mbytDateFormat as Byte = 0 'What format the date is is
'0 = YYYY-MM-DD (default)
'1 = MM-DD-YYYY
'2 = DD-MM-YYYY
'3 = MM-DD
'4 = YYYYMMDD
Private Const mbytTimeFormat as Byte = 0 'The format of the time
'0 = HH:MM:SS (default)
'1 = HH:MM
'2 = HHMMSS
'3 = HHMM
Private const mblnUseMilitaryTime as Boolean = True 'If military time should be used (15:00 instead of 3:00 PM)
Private Const strLogFolderPath As String = "" 'The file path for the folder the log is placed into, leave blank to save to same folder as excel file.
'   ----------------------------------------------------------------------------
'Use the line to call this sub, remove ' before and replace *Log* with what you want logged
'Call WriteToLog(*Log*)
'   ----------------------------------------------------------------------------
Public Sub WriteToLog(strLine As String)
Dim strLogFilePath As String
Dim strUserName As String
Dim fso As Object
Set fso = CreateObject("Scripting.FileSystemObject")
Dim oFile As Object
If gBlLogAction <> True Then GoTo EndLogger 'If logging is not set to true then go to the end of the function
Dim strDate As String
Dim strTime As String
strDate = DateMaker() 'Make the Date
strTime = TimeMaker() 'Make the time
strUserName = (Environ$("Username")) 'Get the user name from the environmental variables
'Make the File Path of the log file.
If strLogFolderPath <> "" Then
    strLogFilePath = strLogFolderPath
Else
    strLogFilePath = ThisWorkbook.Path
End If
If Right(strLogFilePath, 1) <> "\" Then strLogFilePath = strLogFilePath & "\"
If gBlAppendDateToLog Then strLogFilePath = strLogFilePath & strDate & " "
strLogFilePath = strLogFilePath & strBaseLogFileName
'Checks if the log file already exits or not.
If Dir(strLogFilePath) <> "" Then
    'File Does exist, open it for appending
    Set oFile = fso.OpenTextFile(strLogFilePath, 8, True)
Else
    'File does not exist, create it with headers
    Set oFile = fso.CreateTextFile(strLogFilePath)
    oFile.WriteLine "Date           Time            User       | Action"
    oFile.WriteLine "-------------------------------------------------------------------------------------------------"
End If
oFile.WriteLine strDate & "     " & strTime & "     " & strUserName & "   | " & strLine
oFile.Close
EndLogger:
Set fso = Nothing
Set oFile = Nothing
End Sub
'   ----------------------------------------------------------------------------
Private Function DateMaker() As String
'Writes the date in the selected format
Dim strDate As String
Dim strMonth as String
Dim strDay as String
'Add a 0 to the front of the month and day if its less than 10.
'Makes it look nicer.
If Month(Now) < 10 Then
	strMonth = "0" & Month(Now)
Else
	strMonth = Month(Now)
End If
If Day(Now) < 10 Then
    strDay = "0" & Day(Now)
Else
    strDay = Day(Now)
End If
Select Case mbytDateFormat
	Case 0
		strDate = Year(Now) & "-" & strMonth & "-" & strDay
		'Ex 2015-07-22
	Case 1
		strDate = strMonth & "-" & strDay & "-" & Year(Now)
		'Ex 07-22-2015
	Case 2
		strDate = strDay & "-" & strMonth & "-" & Year(Now)
		'Ex 22-07-2015
	case 3
		strDate = strMonth & "-" & strDay
		'Ex 07-22
	case 4
		strDate = Year(Now) & strMonth & strDay
		'Ex 20150722
	case else
		strDate = Year(Now) & "-" & strMonth & "-" & strDay
end select
DateMaker = strDate
End Function
'   ----------------------------------------------------------------------------
Private Function TimeMaker() As String
'Writes the time in the selected format
Dim strTime As String
Dim strHour as String
Dim strMinute as String
Dim strSecond as String
Dim strAMPM as String

if mblnUseMilitaryTime then
	if Hour(Now) < 10 then
		strHour = "0" & Hour(Now)
	else
		strHour = Hour(now)
	end if
else
	if Hour(now) > 12 then
		strAMPM = "PM"
		strHour = (Hour(Now) - 12)
	elseIf Hour(Now) = 12 then
		strAMPM = "PM"
		strHour = "12"
	else
		strAMPM = "AM"
		strHour = Hour(now)
	end if
end if	

If Minute(Now) < 10 Then
    strMinute = "0" & Minute(Now)
Else
    strMinute = Minute(Now)
End If
If Second(Now) < 10 Then
    strSecond = "0" & Second(now)
Else
    strSecond = Second(now)
End If
Select case mbytTimeFormat
	Case 0
		strTime = strHour & ":" & strMinute & ":" & strSecond 
		'EX 15:24:23 or 3:24:23 PM
	case 1
		strTime = strHour & ":" & strMinute
		'EX 15:24 or 3:24 PM
	case 2
		strTime = strHour & strMinute & strSecond
		'EX 152423 or 32423 PM
	case 3
		strTime = strHour & strMinute
		'EX 1524 or 324 PM
	Case Else
		strTime = strHour & ":" & strMinute & ":" & strSecond
end Select
If Not(mblnUseMilitaryTime) then strTime = strTime & " " & strAMPM
TimeMaker = strTime
End Function
```

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

# logging
La journalisation signifie écrire des informations à partir de votre application lorsqu'elle est en cours d'exécution. Lorsqu'une erreur se produit, vous pouvez écrire les détails dans un fichier texte afin d'avoir un enregistrement de l'erreur.

Le code ci-dessous montre une procédure de journalisation très simple 


```
Sub Logger(sType As String, sSource As String, sDetails As String)
 

    Dim sFilename As String
    sFilename = "C:\temp\logging.txt"
    
    ' Archive file at certain size
    If FileLen(sFilename) > 20000 Then
        FileCopy sFilename _
            , Replace(sFilename, ".txt", Format(Now, "ddmmyyyy hhmmss.txt"))
        Kill sFilename
    End If
    
    ' Open the file to write
    Dim filenumber As Variant
    filenumber = FreeFile 
    Open sFilename For Append As #filenumber
    
    Print #filenumber, CStr(Now) & "," & sType & "," & sSource _
                                & "," & sDetails & "," & Application.UserName
    
    Close #filenumber
    
End Sub
```
on peut l'utiliser ainsi

```
Public Const ERROR_DATA_MISSING As Long = vbObjectError + 514

Sub CreateReport()

    On Error Goto eh
    
    If Sheet1.Range("A1") = "" Then
       Err.Raise ERROR_DATA_MISSING, "CreateReport", "Data is missing from Cell A1"
    End If

    ' other code here
Done:
    Exit Sub
eh:
    Logger "Error", Err.Source, Err.Description
End Sub
```

```
Sub ReadingData()
    
    Logger "Information", "ReadingData()", "Starting to read data."
       
    Dim coll As New Collection
    ' add data to the collection
    coll.Add "Apple"
    coll.Add "Pear"
    
    If coll.Count < 3 Then
        Logger "Warning", "ReadingData()", "Number of data items is low."
    End If
    Logger "Information", "ReadingData()", "Number of data items is " & coll.Count
    
    Logger "Information", "ReadingData()", "Finished reading data."

End Sub
```

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

```
Attribute VB_Name = "ErrorHandling"
'---------------------------------------------------------------------------------------
' Module    : ErrorHandling
' Author    : Patrick Rye
' Date      : 7/15/2015
' Purpose   : A very generic way for the code to handle errors, modify this to suit your needs
'---------------------------------------------------------------------------------------

Option Explicit
Public Const gEnableErrorHandling As Boolean = True 'Global varaiable if you should or should not enable error handling
'Full list of errors can be found at: https://support.microsoft.com/en-us/kb/146864
Public Function errHandler(ByRef ErrorNumber As Integer) As Integer
Dim SomeNum As Integer
'On Error GoTo errHandler
'Error Code for the error code, it is not recommended to have this as if it is the same error every time it will get stuck.

'Action Return codes are:
'0 - Do Nothing (Just ignore the error) aka Resume
'1 - Exit sub / function
'2 - Close Workbook
'3 - Skip line, aka Resume Next

Select Case ErrorNumber
    Case 0:
        'No Error
        errHandler = 0 'Do nothing
    Case 3, 5, 10, 13, 16, 17, 20, 35, 59, 62, 63, 74, 91, 92, 93, 94, 323, 328, 361, 364, 365, 380, 381, 382, 383, 385, 387, 393, 394, 422, 423, 424, 425, 429, 430, 432, 438, 440, 442, 443, 445, 446, 447, 448, 451, 452, 454, 455, 457, 458, 459, 460, 461, 480, 1000, 1001, 1004, 1005, 1006, 31004, 31018, 31027, 31032:
        '3 = Return Without GoSub
        '5 = Invalid Procedure
        '10 = Duplicate Definition
        '13 = Type Mismatch
        '16 = String Formula too complex
        '17 = Can't perform requested operation
        '20 = Resume without Error
        '35 = Sub or function not defined.
        '59 = bad record length
        '62 = Input past end of line
        '63 = Bad Record number
        '74 = Can't rename with different drive (aka you tried to movea file to a diff
        '91 = Object variable not set
        '92 = For loop not initialized
        '93 = invalid pattern string
        '94 = invalid use of Null
        '323 = can't load module invalid format
        '361 = Can't Load or unload this object
        '364 = Object was unloaded
        '365 = Unable to laod within this context
        '328 = Illegal parameter; can't write arrays
        '380 = Invalid property value (version 97)
        '381 = Invalid property-array index (version 97)
        '382 = Property Set can't be executed at run time (version 97)
        '383 = Property Set can't be used with a read-only property (version 97)
        '385 = Need property-array index (version 97)
        '387 = Property Set not permitted (version 97)
        '393 = Property Get can't be executed at run time (version 97)
        '394 = Property Get can't be executed on write-only property (version 97)
        '422 = Property not found (version 97)
        '423 = Property or method not found
        '424 = Object Required
        '425 = Invalid object use (version 97)
        '429 = ActiveX component can't create object or return reference to this object (version 97)
        '430 = Class doesn 't support OLE Automation
        '432 = File name or class name not found during Automation operation (version 97)
        '438 = Object doesn 't support this property or method
        '440 = OLE Automation error
        '442 = Connection to type library or object library for remote process has been lost (version 97)
        '443 = Automation object doesn't have a default value (version 97)
        '445 = Object doesn 't support this action
        '446 = Object doesn 't support named arguments
        '447 = Object doesn 't support current locale settings
        '448 =  Named Not argument
        '451 = Object not a collection
        '452 = Invalid Ordinal
        '454 = Code Not resource
        '455 = Code resource lock error
        '457 = This key is already associated with an element of this collection (version 97)
        '458 = Variable uses a type not supported in Visual Basic (version 97)
        '459 = This component doesn't support events (version 97)
        '460 = Invalid clipboard format (version 97)
        '461 = Specified format doesn't match format of data (version 97)
        '480 = Can 't create AutoRedraw image (version 97)
        '1000 = Classname does not have propertyname property
        '1001 = Classname does not have methodname method
        '1004 = Methodname method of classname class failed
        '1005 = Unable to set the propertyname property of the classname
        '1006  = Unable to get the propertyname property of the classname
        '31004 = No Object
        '31018 = Class is not set
        '31027 = Unable to activate object (version 97)
        '31032 = Unable to create embedded object (version 97)
        'These mean that there is something wrong with the actual code.
        SomeNum = MsgBox("There is an issue with the code. Please contact the maker of this workbook.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1 'Exit the running macro
    Case 6, 7, 14, 28, 31001:
        '6 = Overflow
        '7 = Out of Memory
        '14 = Out of String Space (This can be caused by a string being too long as well)
        '28 = Out of Stack Space
        '31001 = Out of memory
        SomeNum = MsgBox("Excel could not allocate the memory it needed to run this macro. There are a couple ways to try to fix this:" & vbCrLf & _
            "1)Close Background Apps" & vbCrLf & "2) Restart Excel" & vbCrLf & "3) Restart your computer" & vbCrLf & _
            "4) Get 64-bit Windows Office on you computer (contact I.T.)", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1 'Exit the running macro
    Case 9:
        '9 = subscript out of range
        SomeNum = MsgBox("Macro could not find something it was looking for." & vbCrLf & "Would you like the macro to try and finish? (This could be very bad).", vbYesNo, "Error: 9")
        If SomeNum = vbYes Then
            errHandler = 3
        Else
            errHandler = 1
        End If
    Case 11:
        '11 = Division by Zero
        SomeNum = MsgBox("Oh God you divided by 0!! The whole world is going to end now!!!", vbOKOnly, "Oh God Why!? Error: 11")
        errHandler = 1
    Case 18:
        '18 = User interrupt occurred
        'User is trying to stop the macro so stop it
        errHandler = 1
    Case 47, 48, 49, 51, 298, 325, 327, 335, 368, 453:
        '47 = too man DLL application clients
        '48 = Error in loading DLL
        '49 = Bad DLL calling convention
        '51 = Internal Error
        '298 = system DLL could not be loaded
        '325 - Invalid format in resource file
        '327 = Data value named was not found
        '335 = Could not access system registry
        '368 = The specified file is out of date. This program requires a newer version.
        '453 = Specified DLL function not found
        'Something is wrong with excel as an application,
        'It might be missing files or installed is incomplete
        SomeNum = MsgBox("Excel application cannot find required files it needs. It may not have installed correctly." _
            & vbCrLf & "First try to close and reopen the file, but if that doesn't work reinstall excel", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 2
    Case 52, 53, 54:
        '52 = Bad file name or number
        '53 = File Not found
        '54 = Bad file mode
        SomeNum = MsgBox("The file path enter is not possible or file was not found, please double check it and try again.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
    Case 55:
        '55 = File already open
        'Nothing bad just trying to open something already open, just ignore it.
        errHandler = 3
    Case 57:
        '57 = Device I/O error
        SomeNum = MsgBox("Device I/O had an error, please ensure it is working properly or restart your computer and try again.", vbOKOnly, "Error: 57")
        errHandler = 2
    Case 58:
        '58 = file already exits
        SomeNum = MsgBox("A file by this name already exists in this folder, please change the name, the location or delete the old file before you try again.", vbOKOnly, "Error: 58")
        errHandler = 1
    Case 61:
        '61 = Disk full
        SomeNum = MsgBox("There is not enough diskspace to save required file.", vbOKOnly, "Error: 61")
        errHandler = 1
    Case 67:
        '67 = too many files
        SomeNum = MsgBox("You have too many files open and cannot open anymore. Close some and try again", vbOKOnly, "Error: 67")
        errHandler = 1
    Case 68, 71:
        '68 = Device unavailable
        '71 = Disk not ready
        SomeNum = MsgBox("The device you are trying to access is unavailable, check that it is working properly or your network access and try again.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
    Case 70:
        '70 = Permission denied
        SomeNum = MsgBox("You do not have permission to write to this location. Please try again.", vbOKOnly, "Error: 70")
        errHandler = 1
    Case 75, 76:
        '75 = Path/file access error
        '76 = Path not found
        SomeNum = MsgBox("Excel cannot find/access specificed file.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
    Case 95:
        '95 = User-defined error
        'User forced an error, try and skip the line
        errHandler = 3
    Case 320, 321:
        '320 = Can't use character device names in specified file names
        '321 = invalid file format
        SomeNum = MsgBox("Save name is invalid change it and try again.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
        'Save Name or file name is invalid
    Case 322, 735:
        '322 = Can't Create necessary temporary file
        '735 = Can 't save file to Temp directory (version 97)
        SomeNum = MsgBox("Excel cannot create necessary temporary files, this could happen if you do not have enough disk space" & _
            "or do not have write access to you TEMP folder. Check these and try again.", vbOKOnly, "Error: 322")
        errHandler = 2
    Case 336, 337, 338, 363:
        '336 = ActiveX component not correctly registered
        '337 = ActiveX component not found
        '338 = ActiveX component did not correctly run
        '363 = Specificed ActiveX control not found
        SomeNum = MsgBox("There was an issue with the ActiveX Components. Close the workbook and try again. Otherwise contact the creator of this workbook.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 2
    Case 360:
        '360 = object already loaded
        errHandler = 3
    Case 400, 402:
        '400 = Form already displayed; can't show modally (version 97)
        '402 = Code must close topmost modal form first (version 97)
        'There is already a user form open, it has to close before the new one can be closed.
        'Use the isUserFormLoaded to check each form and close it.

        errHandler = 0 'Do nothing because we closed all open forms
    Case 419:
        '419 = Permission to use object denied (version 97)
        SomeNum = MsgBox("You cannot access an object, check that the worksheet is not protected.", vbOKOnly, "Error: 419")
        errHandler = 1
    Case 449, 450, 1002, 1003:
        '449 = Argument not optional
        '450 = Wrong number of arguments
        '1002 = Missing required argument argumentname
        '1003 = Invalid number of arguments (versions 5.0 and 7.0)
        SomeNum = MsgBox("You or the macro have tried to use a function incorrectly, double check what you entered and try again.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
    Case 481, 485:
        '481 = Invalid picture (version 97)
        '485 = Invalid picture type (version 97)
        SomeNum = MsgBox("This picture is invalid, please try a different one.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
    Case 482, 483, 484, 486:
        '482 = Printer error (version 97)
        '483 = Printer driver does not support specified property (version 97)
        '484 = Problem getting printer information from the system. Make sure the printer is set up correctly
        '486 = Can 't print form image to this type of printer (version 97)
        SomeNum = MsgBox("There is an error with your printer, please check that it is working properly and can print this format.", vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
    Case Else
        'An Error not defined has occured.
        'Since we don't know what it is end the macro
        SomeNum = MsgBox("Error!" & vbCrLf & Error(ErrorNumber), vbOKOnly, "Error: " & ErrorNumber)
        errHandler = 1
End Select
Exit Function
errorHandler:
    Dim ErrorAction As Integer
    ErrorAction = errHandler(Err.Number)
    Select Case ErrorAction
        Case 0:
            'Ignore Error
            Resume
        Case 1:
            'End Macro
            Exit Function
        Case 2:
            ErrorAction = MsgBox("Do you wish to close excel?", vbYesNo, "Close?")
            If ErrorAction = vbYes Then
                ThisWorkbook.Close
            Else
                Exit Function
            End If
        Case 3:
            'Skip error causing line
            Resume Next
        Case Else
            Exit Function
    End Select

   On Error GoTo 0
   Exit Function

errHandler_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure errHandler of Module ErrorHandling"
End Function
'EXAMPLE SUB
Private Sub ThisIsMyExample()
If gEnableErrorHandling Then On Error GoTo errorHandler
 '**Main Code**
Exit Sub
errorHandler:
    Dim ErrorAction As Integer
    ErrorAction = errHandler(Err.Number)
    Select Case ErrorAction
        Case 0:
            'Ignore Error
            Resume
        Case 1:
            'End Macro
            Exit Sub
        Case 2:
            ErrorAction = MsgBox("Do you wish to close excel?", vbYesNo, "Close?")
            If ErrorAction = vbYes Then
                ThisWorkbook.Close
            Else
                Exit Sub
            End If
        Case 3:
            'Skip error causing line
            Resume Next
        Case Else
            Exit Sub
    End Select
End Sub