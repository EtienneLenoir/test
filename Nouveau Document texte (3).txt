```
Sub import_input()

    Dim target_workbook As Workbook
    Dim Source_Workbook As Workbook
    Dim target_path     As String
    Dim sht_name        As String
    
    Call Optimize_VBA(True)
    On Error GoTo log_err_msg
    
    sht_name = "Extraction GAP3"
    
    If sheet_exists(sht_name) = True Then
        Sheets(sht_name).Delete
    End If
    
    target_path = ws_main.[rng_gap3]
    
    Set target_workbook = Workbooks.Open(target_path)
    Set Source_Workbook = ThisWorkbook
    
    target_workbook.Sheets(1).Copy After:=Source_Workbook.Sheets(1)
    ActiveSheet.name = sht_name
    MsgBox "Task Completed", vbInformation
    
error_exit:
    target_workbook.Close False
    Set target_workbook = Nothing
    Set Source_Workbook = Nothing
    Call Optimize_VBA(False)
    Exit Sub
 
log_err_msg:
    MsgBox "error"
    MsgBox LogErrors(Application.VBE.ActiveCodePane.CodeModule.name, "import_input", Err), _
    vbOKOnly + vbExclamation, "Error in Module " & Application.VBE.ActiveCodePane.CodeModule.name
    Resume error_exit
    
End Sub

Sub Get_Rw_Protect(Optional path_from_range As Boolean)
    
    Call Optimize_VBA(True)

    Dim target_workbook                 As Workbook
    Dim sht                             As Worksheet

 
    Dim my_dico                         As New Dictionary

    str_date = fct_get_last_day(month_ante_var:=1)
    output_synthese_col_name = ""
    output_synthese_col_rw_protect = ""
    
    On Error GoTo LogErr
    
    ws_gap3_rw_protect.Range("A2").CurrentRegion.Clear
    
    target_path = "" & Mid(str_date, 6, 2) & "-" & Left(str_date, 4) & ".xlsx"
    
    If file_exist(target_path) = False Then
        path_folder = ""
        target_path = fct_FindFileInFolder(path_folder)
        If file_exist(target_path) = False Then
            MsgBox "The file RW protect doesn't exist or doesn't find in : " & vbCrLf & path_folder, vbInformation, "Output rapport de synthèse " & Mid(str_date, 6, 2) & "-" & Left(str_date, 4)
            Exit Sub
        End If
    End If
    
    ws_main.[rng_rwprotect] = target_path
        
    Set target_workbook = Workbooks.Open(target_path)
    Set sht = target_workbook.Sheets(1)

    With sht
        my_tab = .Range("A1").CurrentRegion
1       col_name = Application.WorksheetFunction.Match(output_synthese_col_name, .Rows("1:1"), 0)
2       col_rw_protect = Application.WorksheetFunction.Match(output_synthese_col_rw_protect, .Rows("1:1"), 0)
    End With
    
    For i = LBound(my_tab, 1) + 1 To UBound(my_tab, 1)
        If Not my_dico.Exists(my_tab(i, col_name)) Then
            my_dico.Add my_tab(i, col_name), my_tab(i, col_rw_protect)
        End If
    Next i
    
    ReDim Tab_result(1 To my_dico.count, 1 To 2)
    i = 1
    For Each elmt_key In my_dico
    
        Tab_result(1, 1) = "Clc Protect Code"
        Tab_result(1, 2) = "Clc Rw Protect"
        Tab_result(i, 1) = elmt_key
        Tab_result(i, 2) = my_dico.Item(elmt_key)
        i = i + 1
    Next elmt_key
    Set my_dico = Nothing
 
    With ws_gap3_rw_protect
        .Range("A1").Resize(UBound(Tab_result, 1), UBound(Tab_result, 2)) = Tab_result
    End With
    
    If path_from_range = True Then
         MsgBox "Import imput (Rw Protect) done !", vbInformation, "Import imput (Rw Protect)"
    End If
    
    ws_main.[rng_rw_date_now] = Format(Now, "YYYYMMDD HH:MM")
    
error_exit:
    target_workbook.Close
    Set target_workbook = Nothing
    Set sht = Nothing
    Set Tab_result = Nothing
    Call Optimize_VBA(False)
    Exit Sub
 
LogErr:
    Select Case Erl
    Case 1
        MsgBox LogErrors(Application.VBE.ActiveCodePane.CodeModule.name, "Get_Rw_Protect", Err, "Champ : " & output_synthese_col_name & " introuvable dans " & target_path), _
        vbOKOnly + vbExclamation, "Error in Module " & Application.VBE.ActiveCodePane.CodeModule.name
    Case 2
        MsgBox LogErrors(Application.VBE.ActiveCodePane.CodeModule.name, "Get_Rw_Protect", Err, "Champ : " & output_synthese_col_rw_protect & " introuvable dans " & target_path), _
        vbOKOnly + vbExclamation, "Error in Module " & Application.VBE.ActiveCodePane.CodeModule.name
    Case Else
         MsgBox LogErrors(Application.VBE.ActiveCodePane.CodeModule.name, "Get_Rw_Protect", Err), _
        vbOKOnly + vbExclamation, "Error in Module " & Application.VBE.ActiveCodePane.CodeModule.name
    End Select
 
End Sub


Function load_dict_Glad_name_ResidualRW() As Dictionary 'Pour Titrisation rwa

    Dim my_dico         As New Dictionary
    Dim my_tab          As Variant
    Dim i               As Integer
    Dim col_name        As Integer
    Dim col_rw_protect  As Integer
    
    With ws_gap3_rw_protect
        my_tab = .Range("A1").CurrentRegion
        col_name = Application.WorksheetFunction.Match("CLC_PROTECT_TYPE", .Rows("1:1"), 0)
        col_rw_protect = Application.WorksheetFunction.Match("CLC_PROTECT_RW", .Rows("1:1"), 0)
    End With

    For i = LBound(my_tab, 1) + 1 To UBound(my_tab, 1)
 
        If Not my_dico.Exists(my_tab(i, col_name)) Then
            my_dico.Add my_tab(i, col_name), my_tab(i, col_rw_protect)
        End If

    Next i
       
    Set load_dict_Glad_name_ResidualRW = my_dico
    Set my_dico = Nothing
    Set my_tab = Nothing
    
End Function


Public Function get_range_to_import(ByVal ws_name As String, Optional ByRef wb As Workbook) As String
    
    Dim used_range As Range
    Dim n_col As Long
    Dim n_row As Long
    Dim ws As Worksheet
    
    If Not wb Is Nothing Then
        Set ws = wb.Worksheets(ws_name)
    Else
        Set ws = ThisWorkbook.Worksheets(ws_name)
    End If
    
    n_col = ws.UsedRange.Columns.count
    n_row = ws.UsedRange.Rows.count
    
    Set used_range = ws.Range(ws.Cells(1, 1), ws.Cells(n_row, n_col))
    
    get_range_to_import = ws_name & "!" & Replace(used_range.AddressLocal, "$", "")
    
End Function



Sub import_previous()

    Dim sht                 As Worksheet
    Dim target_workbook     As Workbook
    Dim sht_name            As String
    Dim path_range          As String
    Dim strFile             As String
    Dim last_row            As Long
    
    Application.DisplayAlerts = False
    
    'sht_name = ws_home.[rng_sht_name]
    path_range = ws_home.[rng_working_directory]
    strFile = Open_filename(path_range)

    Set target_workbook = Workbooks.Open(strFile)
    
    Set sht = target_workbook.Sheets(1)
    
    last_row = sht.Range("A1").End(xlDown).row
    ws_Raw_Corrected_All_Entity.Cells.Clear
    sht.UsedRange.Copy ws_Raw_Corrected_All_Entity.Range("A2")
    ws_Raw_Corrected_All_Entity.Range("A1:K1") = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
    Application.CutCopyMode = False
    
    target_workbook.Close False
    
    Call replace_dot_or_coma(ws_liquid_intermediate, ".", ",")
    Call replace_dot_or_coma(ws_Raw_Corrected_All_Entity, ".", ",")
    Application.DisplayAlerts = True

End Sub


Function Open_filename(path_range As String) As String
  Dim fld As FileDialog
  Dim strFilePath As String
  Set fld = Application.FileDialog(msoFileDialogOpen)
  With fld
    .InitialFileName = path_range
    .Show
  End With
  strFilePath = fld.SelectedItems(1)
  Open_filename = strFilePath
End Function



Public Sub ImportExcel(SourcePath As String, SheetName As String, FirstColumnName As String, IsMAM As Boolean, Optional HeaderInFile As Boolean = True, Optional NewHeaderTab As Variant = Empty, Optional isXlDown As Boolean = True)
    
    On Error GoTo errorhandler
    
    Dim SourceName As String
    Dim rngDataBegin As Range, BeginRow As Integer, BeginCol As Integer
    Dim sDataType_ As Variant
    
    Call StatusBar("Importing Data from : " & SourcePath)
    
    Application.DisplayAlerts = False
    
    Workbooks.Open FileName:=SourcePath
    
    SourceName = Workbooks.Application.ActiveWorkbook.name
    
    With Workbooks(SourceName).Sheets(SheetName)
        
        'Filtre si MAM
        If IsMAM Then
            .Columns("A:B").Delete
            .Columns("C").Delete
            .Columns("E:F").Delete
            .Columns("F:G").Delete
            .Columns("H:V").Delete
            .Columns("I:L").Delete
            .Columns("J:U").Delete
            .Columns("L").Delete
            .Columns("M:N").Delete
            .Columns("N:Y").Delete
        End If
        
        'Return le df
        If HeaderInFile Then
            'Trouve le début de la donnée
            Set rngDataBegin = .Cells.Find(What:=FirstColumnName, LookAt:=xlWhole, SearchOrder:=xlByRows)
            
            If rngDataBegin Is Nothing Then GoTo errorhandler
            
            sHeader_ = .Range(rngDataBegin, rngDataBegin.End(xlToRight))
            If isXlDown Then
                vData_ = .Range(rngDataBegin.Offset(1), .Cells(rngDataBegin.End(xlDown).row, rngDataBegin.End(xlToRight).Column))
            Else
                vData_ = .Range(rngDataBegin.Offset(1), .Cells(.Cells(Rows.count, rngDataBegin.Column).End(xlUp).row, rngDataBegin.End(xlToRight).Column))
            End If
        ElseIf Not HeaderInFile Then
            BeginRow = InputBox("Indiquer la ligne de la première cellule de la donnée à importer", "Begin Cell coordinates")
            BeginCol = InputBox("Indiquer la colonne de la première cellule de la donnée à importer", "Begin Cell coordinates")
            Set rngDataBegin = .Cells(BeginRow, BeginCol)
            
            If IsEmpty(NewHeaderTab) Then GoTo errorhandler
            
            ReDim sHeader_(1, UBound(NewHeaderTab, 1))
            RowData = 0
            For Each id In NewHeaderTab
                RowData = RowData + 1
                sHeader_(1, RowData) = id
            Next id
            If isXlDown Then
                vData_ = .Range(rngDataBegin, .Cells(rngDataBegin.End(xlDown).row, rngDataBegin.End(xlToRight).Column))
            Else
                vData_ = .Range(rngDataBegin, .Cells(.Cells(Rows.count, rngDataBegin.Column).End(xlUp).row, rngDataBegin.End(xlToRight).Column))
            End If
        End If
        
    End With
    
    'ferme le fichier ouvert
    Workbooks(SourceName).Close
    Application.DisplayAlerts = True
    
    Set dicoColId_ = FilldicoColId(sHeader_)
    Set dicoColType_ = FilldicoColType(sHeader_, vData_)
    
    Exit Sub
errorhandler:
    If rngDataBegin Is Nothing Then
        Call MsgBox("Première colonne non trouvée : vérifier le nom" & vbCrLf & Err.description, vbCritical, "ERROR : Import Excel")
    ElseIf Not HeaderInFile And UBound(vData_, 2) <> UBound(NewHeaderTab, 1) Then
        Call MsgBox("Le nouveau header ne corespond pas au nombre de colonnes importé" & vbCrLf & Err.description, vbCritical, "ERROR : Import Excel")
    End If
End Sub


Public Sub ImportFromCell(rngDataBegin As Range)

    On Error GoTo errorhandler
    
    Call StatusBar("Importing Data from : " & rngDataBegin.value)
    
    Dim sDataType_ As Variant

    If rngDataBegin Is Nothing Then GoTo errorhandler
    
    sHeader_ = Range(rngDataBegin, rngDataBegin.End(xlToRight))
    
    vData_ = Range(rngDataBegin.Offset(1), Cells(rngDataBegin.End(xlDown).row, rngDataBegin.End(xlToRight).Column))
    
    Set dicoColId_ = FilldicoColId(sHeader_)
    Set dicoColType_ = FilldicoColType(sHeader_, vData_)
    
    Exit Sub
errorhandler:
    If rngDataBegin Is Nothing Then
        Call MsgBox("Première colonne non trouvée : vérifier la cellule" & vbCrLf & Err.description, vbCritical, "ERROR : Import from Intern Sheet")
    ElseIf IsEmpty(rngDataBegin) Then
        Call MsgBox("Cellule indiquée vide", vbCritical, "ERROR : Import from Intern Sheet")
    Else
        Call MsgBox(Err.description, vbCritical, "ERROR : Import from Intern Sheet")
    End If
End Sub



Public Sub ImportMOYCH(SourcePath As String, Optional SheetName As String = "CARD", Optional ColumnIdCurrency As Integer = 1, Optional ColumnIdRate As Integer = 3)
    
    On Error GoTo errorhandler
    
    Dim SourceName As str
    Dim rngDataBegin As Range
    Dim vCurrency As Variant, vRate As Variant
    
    Application.DisplayAlerts = False
    
    Workbooks.Open FileName:=SourcePath
    
    SourceName = Workbooks.Application.ActiveWorkbook.name

    With Workbooks(SourceName).Sheets(SheetName)
        vCurrency = .Range(.Cells(1, ColumnIdCurrency), .Cells(1, ColumnIdCurrency).End(xlDown))
        vRate = .Range(.Cells(1, ColumnIdRate), .Cells(1, ColumnIdRate).End(xlDown))
        For RowData = LBound(vCurrency, 1) To UBound(vCurrency, 1)
            If Not dicoCurrencyRate_.Exists(vCurrency(RowData, 1)) Then
                dicoCurrencyRate_.Add vCurrency(RowData, 1), vRate(RowData, 1)
            End If
        Next RowData
        If Not dicoCurrencyRate_.Exists("EUR") Then
            dicoCurrencyRate_.Add "EUR", 1
        ElseIf dicoCurrencyRate_.Exists("EUR") Then
            dicoCurrencyRate_.Remove "EUR"
            dicoCurrencyRate_.Add "EUR", 1
        End If
    End With
    
    'ferme le fichier ouvert
    Application.DisplayAlerts = True
    Exit Sub
errorhandler:
    Call MsgBox(Err.description, vbCritical, "ERROR : Import MOYCH")
    Exit Sub
End Sub


'+++++++++++++GTTVA

Function FctVerifyExtension(sFile As String, TypeFile As String)

    Dim FSO     As Object
    Dim StrType As String
    Set FSO = CreateObject("Scripting.FileSystemObject")
    StrType = FSO.GetExtensionName(sFile)
    
    Select Case TypeFile
    
        Case "xlsx"
            If Not StrType = TypeFile Then
                MsgBox "Erreur Import CTF, l'extension du fichier doit etre un .xlsx", vbInformation, "Import CTF"
                End
            End If
        Case "csv"
            If Not StrType = TypeFile Then
                MsgBox "Erreur Import IFAT, l'extension du fichier : " & sFile & " doit etre un .csv", vbInformation, "Import IFAT"
                End
            End If
        End Select

End Function



Sub cc()
    Dim o_test          As New cls_mapping
    Dim ws_data_input   As String
    Dim ws_data_display As String
    Dim type_CTF        As Boolean
    Dim prod
    
    type_CTF = True
    
    If type_CTF = True Then
        ws_data_input = ws_input_CTF.name
    Else
        ws_data_input = ws_input_CTF.name
    End If
    
    prod = o_test.fct_display_MainMapping(display_NumDem_CTF:=type_CTF, ws_data_input:=ws_data_input)

End Sub



Function MainImportData(IfCFT As Boolean)

    Dim sht                     As Worksheet
    Dim DictLabelMapping        As Dictionary
    Dim DictFileNameIfat        As Dictionary
    Dim KeyFile                 As Variant
    Dim IfIFA                   As Boolean
    Dim BoolSeveralImportTemp   As Boolean
    Dim PathRange               As String
    Dim RangeAddress            As String
    Dim FullPath                As String
    Dim FullPathFileLight       As String
    Dim StrRepIfat              As String
    Dim StrToFindInCSv          As String
    Dim WsCtf       As String
    Dim WsIfat      As String
    
    On Error GoTo errorhandler:
    
    RangeAddress = ws_mapping.Range("rng_mapping_input_CTF").Address
    Set DictLabelMapping = FctLoadDictLabel(StartCellTemp:=RangeAddress, array_type:="v")
    
    If IfCFT = True Then
        PathRange = ws_main.[rng_path_CTF]
        WsCtf = ws_input_CTF.name
    Else 'IFAT
        StrRepIfat = ws_main.[rng_path_ifat]
        WsIfat = ws_input_ifac.name
    End If

    If IfCFT = True Then
        '1)Clear
        Call ClearData(WsNameTemp:=WsCtf, StartCellTemp:="A3", NumMethod:=4)
        '2)Vérification Input
        Set sht = FctDefineShtAndVerifyPath(PathRange)
        Call FctVerifyExtension(PathRange, "xlsx")
        
        '3)Récupération données
        Call TreatmentData("xlsx", ShtTemp:=sht, StrPathRange:=PathRange, WsDisplayResult:=WsCtf, DictLabelMapping:=DictLabelMapping, IfImputCTF:=IfCFT, _
                            BoolSeveralImport:=False, BoolSql:=False)
    Else
        'IFAT
        StrToFindInCSv = ws_main.[rng_ifat_keyword]
        
        '1)Clear
        Call ClearData(WsNameTemp:=WsIfat, StartCellTemp:="A3", NumMethod:=4)
        
        '2)Récuperation des fichiers CSV IFAT
        Set DictFileNameIfat = FctGetDictFileNameIfat(FctCheckRep(StrRepIfat), StrToFindInCSv)
        
        '3)Check label Input - Mapping
        If DictFileNameIfat.count >= 1 Then
            'Vérification des labels IFAT à partir d'un seul fichier IFAT le moins volumineux retrouvé dans le dossier import IFAT
            FullPathFileLight = FctCheckRep(StrRepIfat) & CStr(DictFileNameIfat.Keys(0))
           If FctCheckLabelInput("csv", FullPathFileLight, DictLabelMapping) = False Then
                Exit Function
            End If
        End If
        '4)Récupération données
        BoolSeveralImportTemp = False
        For Each KeyFile In DictFileNameIfat.Keys
        
            Debug.Print KeyFile
            
            '2)Vérification Input
            FullPath = FctCheckRep(StrRepIfat) & CStr(KeyFile)
            '3)Récupération données
            Call TreatmentData("csv", StrPathRange:=FullPath, WsDisplayResult:=WsIfat, DictLabelMapping:=DictLabelMapping, IfImputCTF:=IfCFT, _
                                BoolSeveralImport:=BoolSeveralImportTemp, BoolSql:=True)
            BoolSeveralImportTemp = True
        Next KeyFile
    End If
    
    Set DictLabelMapping = Nothing
    Exit Function
errorhandler:
    MsgBox "Error Import, vérifier le mapping", vbCritical
    Err.Raise 1
    Exit Function

End Function

'Récupération données
Sub TreatmentData(TypeImport As String, StrPathRange As String, WsDisplayResult As String, IfImputCTF As Boolean, DictLabelMapping As Dictionary, _
                        BoolSeveralImport As Boolean, Optional ShtTemp As Worksheet, Optional BoolSql As Boolean)

    Dim ArrayResult             As Variant
    Dim LastRow                 As Variant
    Dim WsResult                As Worksheet
    Dim DictInputArrRstAndLabel As Dictionary
    
    'Chargement données dans variable tableau et classement pour création clé concat mapping
    If IfImputCTF = True Then
        ArrayResult = ImportCtf(ShtTemp, DictLabelMapping)
        'Workbooks(Dir(StrPathRange)).Close False
    Else
    
        If BoolSql = False Then
            'Méthode Array
            Set DictInputArrRstAndLabel = FctGetDictInputArrRstAndLabel(TypeImport, StrPathRange, DictLabelMapping)
            ArrayResult = ImportIfatMethodArray(DictLabelMapping, DictInputArrRstAndLabel)
            Set DictInputArrRstAndLabel = Nothing
        Else
            'Méthode SQL
            Call ImportIfatMethodSql(StrPathRange, DictLabelMapping, WsDisplayResult, BoolSeveralImport)
        End If
        
    End If

    If BoolSql = False Then
    
    Set WsResult = Workbooks(CStr(ThisWorkbook.name)).Worksheets(WsDisplayResult)
   
   
        With WsResult
            If BoolSeveralImport = False Then
                .Range("A2").Resize(UBound(ArrayResult, 1), UBound(ArrayResult, 2)).value = ArrayResult
                .Range("A2").Resize(UBound(ArrayResult, 1), UBound(ArrayResult, 2)).HorizontalAlignment = xlCenter
            Else
                LastRow = .Cells(Rows.count, "A").End(xlUp).Offset(1, 0).row
                .Range("A" & LastRow).Resize(UBound(ArrayResult, 1), UBound(ArrayResult, 2)).value = ArrayResult
                'Suppression ligne title
                .Rows(LastRow).Delete
                .Range("A" & LastRow).Resize(UBound(ArrayResult, 1), UBound(ArrayResult, 2)).HorizontalAlignment = xlCenter
            End If
        End With
        
    End If
    
End Sub




'Chargement données dans variable tableau et classement pour création clé concat mapping
Function ImportCtf(sht_temp As Worksheet, dico_label As Dictionary) As Variant

    Dim ArrayInput          As Variant
    Dim ArrayResult         As Variant
    Dim key_LabelOrder      As Variant
    Dim key_LabelMissed     As Variant
    Dim dico_LabelMissed    As Dictionary
    Dim msg_LabelMissed     As String
    Dim i                   As Long
    Dim j                   As Integer
    Dim count               As Integer
    Dim without_title       As Byte
    Dim NumRowBegin         As Byte
    Dim LabelFound          As Boolean

    Set dico_LabelMissed = New Dictionary
    without_title = 0 'if true=1
    NumRowBegin = 1 'if true=2
    
    If sht_temp.Range("A1") = "" Then
        MsgBox "Import impossible, les données des inputs doivent débuter en cellule A1", vbCritical
        Exit Function
    End If
    
    'on charge les données dans une variable tableau
    ArrayInput = sht_temp.Range("A1").CurrentRegion
    
    Workbooks(Dir(CStr(ws_main.[rng_path_CTF]))).Close False
  
    ReDim ArrayResult(NumRowBegin To UBound(ArrayInput, 1) + without_title, 1 To dico_label.count)
    count = 1
    For Each key_LabelOrder In dico_label.Keys
        If Not dico_label(key_LabelOrder) = "N contrat" Then
            LabelFound = False
            For j = LBound(ArrayInput, 2) To UBound(ArrayInput, 2)
                'vérification matching avec les labels attendus
                If dico_label.Exists(CStr(ArrayInput(1, j))) = True Then
                    'Boucle+condition pour respecter l'odre précis des champs concatenés du mapping
                    If ArrayInput(1, j) = key_LabelOrder Then
                        LabelFound = True
                        For i = LBound(ArrayInput, 1) + without_title To UBound(ArrayInput, 1)
                            ArrayResult(i, count) = FctFillIfEmpty(ArrayInput(i, j))
                            'On inverse le signe de la colonne montant
                            If ArrayResult(1, count) = ws_mapping.Range("rng_mapping_InputAmount") And i <> 1 Then
                                ArrayResult(i, count) = -(ArrayInput(i, j))
                            End If
                        Next i
                        'on renomme les labels avec ceux du mapping
                        ArrayResult(1, count) = dico_label(key_LabelOrder)
                        count = count + 1
                    End If
                End If
            Next j
            If LabelFound = False Then
                If Not dico_LabelMissed.Exists(key_LabelOrder) Then: dico_LabelMissed.Add key_LabelOrder, ""
            End If
        End If
    Next key_LabelOrder
    
    For Each key_LabelMissed In dico_LabelMissed.Keys
        msg_LabelMissed = msg_LabelMissed & "," & key_LabelMissed
    Next
    
    If Len(msg_LabelMissed) > 1 Then: MsgBox "Attention des champs mapping n'existe pas dans l'input :" & Chr(13) & Chr(10) & msg_LabelMissed _
    & Chr(13) & Chr(10) & "veuillez les ajouter ou modifier le mapping", vbCritical, "Import de CTF"
    
    ImportCtf = ArrayResult
    Set ArrayResult = Nothing
    Set dico_LabelMissed = Nothing
      
End Function

Function FctDefineShtAndVerifyPath(path_range As String) As Worksheet

    Dim target_workbook     As Workbook
    Dim sht                 As Worksheet
    
    If FctFileExist(path_range) = False Then
        MsgBox "The file :" & vbCrLf & vbCrLf & path_range & vbCrLf & vbCrLf & " doesn't exist", vbCritical, "Error input" & Dir(path_range)
        Exit Function
    End If
    
    If FctIsWorkbookOpen(Dir(path_range)) = True Then
        Set target_workbook = Workbooks(Dir(path_range))
        Set FctDefineShtAndVerifyPath = target_workbook.Sheets(1)
    Else
        Set target_workbook = Workbooks.Open(path_range, , True)
        Set FctDefineShtAndVerifyPath = target_workbook.Sheets(1)
    End If

End Function

'================================================================================================================='
'===============================================Import (IFAT)====================================================='
'================================================================================================================='

'Récupérations de tous les fichiers CSV IFAT et de leurs tailles
Function FctGetDictFileNameIfat(StrPathFolder As String, StrToFindInCSv As String) As Dictionary

    Dim oFSO                As Object
    Dim OFolder             As Object
    Dim oFile               As Object
    Dim OFileFound          As Object
    Dim DictFileName_Size   As New Dictionary
    Dim StrSearch           As String
    Dim NameFileFound       As String
    Dim FileSize            As Long
    Dim BoolFileFound       As Boolean

    Set oFSO = CreateObject("Scripting.FileSystemObject")
    Set OFolder = oFSO.GetFolder(StrPathFolder)
    
    StrSearch = StrToFindInCSv
    BoolFileFound = False
    
    'Récuperation de tous les noms des fichiers d'imports IFAT
    If oFSO.FolderExists(StrPathFolder) Then
        For Each oFile In OFolder.Files
            If InStrRev(Dir(oFile), StrSearch) > 0 Then
                Call FctVerifyExtension(CStr(oFile), "csv")
                NameFileFound = Right(oFile, Len(oFile) - InStrRev(oFile, "\"))
                BoolFileFound = True
                Set OFileFound = oFSO.GetFile(StrPathFolder & NameFileFound)
                FileSize = OFileFound.Size
                'Dictionaire Non Fichier - Taille
                If Not DictFileName_Size.Exists(NameFileFound) Then
                    DictFileName_Size.Add NameFileFound, FileSize
                End If
            End If
        Next oFile
    End If
    
    'Tri décroissant du dictionaire
    Set FctGetDictFileNameIfat = FctSortDictByValues(DictFileName_Size, xlAscending)
    
    Set DictFileName_Size = Nothing
    Set oFSO = Nothing
    Set OFolder = Nothing
    Set OFileFound = Nothing
    
    If BoolFileFound = False Then
        MsgBox "Aucun fichier avec le mot clé : " & StrSearch & Chr(13) & Chr(10) & _
                "retrouvé dans le chemin suivant : " & StrPathFolder, vbInformation, "Récuperation des fichiers d'import IFAT"
    End If
    
End Function

'========================================Import Treatment SQL(IFAT)==============================================='

Function ImportIfatMethodSql(FullPath As String, DictLabelMapping As Dictionary, WsDisplayResult As String, BoolSeveralImport As Boolean) As Variant

    Dim cn                      As New ADODB.Connection
    Dim rst                     As ADODB.Recordset
    Dim DictGroupBy             As New Dictionary
    Dim DictLabel               As New Dictionary
    Dim KeyLabel                As Variant
    Dim ArrayRst                As Variant
    Dim Fichier                 As String
    Dim Rep                     As String
    Dim StrGroupByTopIntExt     As String
    Dim StrGroupByZoneFiscale   As String
    Dim StrGroupByCoefTax       As String
    Dim StrGroupByMethAdpt      As String
    Dim StrGroupByZuccursale    As String
    Dim StrGroupByGtva          As String
    Dim StrGroupByNcontrat      As String
    Dim StrPccoSuffixe          As String
    Dim StrPcecEvolan           As String
    Dim StrPcecRglt             As String
    Dim StrAmount               As String
    Dim KeyWordSelect           As String
    Dim SelectSql               As String
    Dim AmountSql               As String
    Dim FullSelect              As String
    Dim KeyWordGroupBy          As String
    Dim GroupBySql              As String
    Dim KeyWordHaving           As String
    Dim AmountHavingSql         As String
    Dim FullRequest             As String
    Dim i                       As Long
    Dim LastRow                 As Long

    On Error GoTo errorhandler:
    
    Rep = Left(FullPath, InStrRev(FullPath, Application.PathSeparator))
    Fichier = Dir(FullPath)
    
    ''Modification  base de registre du fichier Schema.ini dans le répertoire qui contient le CSV (ADODB csv USA ',')
    Call FctModifyShemaIniCsv(Rep, Fichier, "Delimited(;)")
   
'    ----------------------------------------------------
'   Objectif créer cette requete de manière dynamique
'    ----------------------------------------------------
'    Select FIRST([PCCO suffixé]) AS [PCCO Suffixe], FIRST([PCEC rest Evolan || 700 - AS]) AS [PCEC de reporting], FIRST([PCEC calc rglt || 31 - AS]) AS [PCEC calcule], [Top int / ext] AS [Top Int-Ext], [Cd Zone fiscale] AS [Zone Fiscale], [Cd famille coef de taxation] AS [Famille Coeff Taxation], [TAX_METH_COD_ADPT] AS [Methode Calcul Coeff Taxation], [FLAG_SUCC] AS [Succursale], [Flag Code partenaire GTVA] AS [GTVA], [N° cont] AS [N contrat], abs(sum([Mt en devise de solde converti en euros])) AS [Amount]
'    FROM [GRPTVA_IFAT_CTF_2022_1#csv]
'    Group By
'    [Top int / ext] , [Cd Zone fiscale], [Cd famille coef de taxation], [TAX_METH_COD_ADPT], [FLAG_SUCC], [Flag Code partenaire GTVA], [N° cont]
'    HAVING
'    Sum ([Mt en devise de solde converti en euros]) < 0
 
    With ws_mapping
        StrGroupByTopIntExt = CStr(.Range("rng_mapping_TopIntExt"))
        StrGroupByZoneFiscale = CStr(.Range("rng_mapping_ZoneFiscale"))
        StrGroupByCoefTax = CStr(.Range("rng_mapping_FamCoeffTax"))
        StrGroupByMethAdpt = CStr(.Range("rng_mapping_MethodClcCoeffTax"))
        StrGroupByZuccursale = CStr(.Range("rng_mapping_Succursale"))
        StrGroupByGtva = CStr(.Range("rng_mapping_GTVA"))
        StrGroupByNcontrat = CStr(.Range("rng_mapping_contrat"))
        DictGroupBy.Add StrGroupByTopIntExt, DictLabelMapping(StrGroupByTopIntExt)
        DictGroupBy.Add StrGroupByZoneFiscale, DictLabelMapping(StrGroupByZoneFiscale)
        DictGroupBy.Add StrGroupByCoefTax, DictLabelMapping(StrGroupByCoefTax)
        DictGroupBy.Add StrGroupByMethAdpt, DictLabelMapping(StrGroupByMethAdpt)
        DictGroupBy.Add StrGroupByZuccursale, DictLabelMapping(StrGroupByZuccursale)
        DictGroupBy.Add StrGroupByGtva, DictLabelMapping(StrGroupByGtva)
        DictGroupBy.Add StrGroupByNcontrat, DictLabelMapping(StrGroupByNcontrat)
        StrPccoSuffixe = CStr(.Range("rng_mapping_input_CTF"))
        StrPcecEvolan = CStr(.Range("rng_mapping_PCECReporting"))
        StrPcecRglt = CStr(.Range("rng_mapping_PCEC_Calcule"))
        DictLabel.Add StrPccoSuffixe, DictLabelMapping(StrPccoSuffixe)
        DictLabel.Add StrPcecEvolan, DictLabelMapping(StrPcecEvolan)
        DictLabel.Add StrPcecRglt, DictLabelMapping(StrPcecRglt)
        StrAmount = CStr(.Range("rng_mapping_InputAmount"))
    End With
        
    KeyWordSelect = "Select "
    For Each KeyLabel In DictLabel.Keys
        SelectSql = SelectSql & "FIRST([" & CStr(KeyLabel) & "]) AS " & "[" & DictLabel(CStr(KeyLabel)) & "], "
    Next KeyLabel
    For Each KeyLabel In DictGroupBy.Keys
        SelectSql = SelectSql & "[" & CStr(KeyLabel) & "] AS " & "[" & DictGroupBy(CStr(KeyLabel)) & "], "
    Next KeyLabel
    AmountSql = "abs(sum([" & StrAmount & "])) AS " & "[" & DictLabelMapping(StrAmount) & "] "
    FullSelect = KeyWordSelect & SelectSql & AmountSql & " FROM [" & Replace(Fichier, ".", "#") & "]"
        
    KeyWordGroupBy = " Group By "
    For Each KeyLabel In DictGroupBy.Keys
        GroupBySql = GroupBySql & "[" & CStr(KeyLabel) & "], "
    Next KeyLabel
    GroupBySql = KeyWordGroupBy & FctDelComa(GroupBySql)

    KeyWordHaving = " HAVING "
    AmountHavingSql = KeyWordHaving & "sum([" & StrAmount & "]) < 0"

    FullRequest = FullSelect & GroupBySql & AmountHavingSql

    Set rst = New ADODB.Recordset
    With cn
        .Open "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & Rep & ";Extended Properties=""Text;HDR=YES;FMT=Delimited(;)"""
        Set rst = .Execute(FullRequest)
        'Affiche des Résultats
        With Worksheets(WsDisplayResult)
            If BoolSeveralImport = False Then
                For i = 0 To rst.Fields.count - 1
                    .Range("A2").Offset(, i) = rst(i).name
                Next i
                .Range("A3").CopyFromRecordset rst
            Else
                LastRow = .Cells(Rows.count, "A").End(xlUp).Offset(1, 0).row
                .Range("A" & LastRow).CopyFromRecordset rst
            End If
        End With
        rst.Close
        .Close
     End With
     
ErrorExit:
    Set rst = Nothing
    Set cn = Nothing
    Set DictGroupBy = Nothing
    Set DictLabel = Nothing
    Exit Function
      
errorhandler:
    MsgBox "Erreur Import IFAT, vérifier correspondance entre le mapping et les libellés des colonnes du fichier :" & FullPath, vbCritical, "Import IFAT"
    Resume ErrorExit
End Function

'==================================Import Treatment Array Dynamic (IFAT)=========================================='

Function ImportIfatMethodArray(DictLabelMapping As Dictionary, DictInputArrRstAndLabel As Dictionary) As Variant
    
    Dim ArrayTempFiltered()         As Variant
    Dim KeyDict                     As Variant
    Dim KeyDictTemp                 As Variant
    Dim ArrayInput                  As Variant
    Dim DictContract                As Dictionary
    Dim DictTemp                    As Dictionary
    Dim DictContractUnique          As Dictionary
    Dim i                           As Long
    Dim j                           As Long
    Dim count                       As Long
    Dim colonneAmount               As Integer
    Dim colonneTypeContrat          As Integer
    Dim colonnePCCOSuffixe          As Integer
    Dim colonnePCECReporting        As Integer
    Dim colonnePECEC_Calcule        As Integer
    Dim colonneTopIntExt            As Integer
    Dim colonneZoneFiscale          As Integer
    Dim colonneFamCoeffTax          As Integer
    Dim colonneMethodClcCoeffTax    As Integer
    Dim colonneSuccursale           As Integer
    Dim colonneGTVA                 As Integer
    Dim KeyInput                    As String
    Dim KeyTemp                     As String
    Dim KeyInputLabel               As String
    Dim StrValue                    As String
    Dim DimMinus                    As Byte

    Set DictContractUnique = New Dictionary
    Set DictContract = New Dictionary
    Set DictTemp = New Dictionary
    ArrayInput = DictInputArrRstAndLabel("ArrayRst")
    
    'Optimisation ram
    DictInputArrRstAndLabel.Remove "ArrayRst"
    
    'Check Label Input - ws_Mapping
    For Each KeyDict In DictLabelMapping.Keys
        If Not DictInputArrRstAndLabel.Exists(CStr(KeyDict)) Then
            MsgBox "Attention des champs mapping n'existe pas dans l'input :" & Chr(13) & Chr(10) _
                    & Chr(13) & Chr(10) & "veuillez vérifier le mapping", vbCritical, "Erreur Import de IFAT "
            Exit Function
        End If
    Next KeyDict
    
    'Récupération position des colonnes
    With ws_mapping
        'Array RecordSet
        DimMinus = 1
        colonneAmount = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_InputAmount"))) - DimMinus
        colonneTypeContrat = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_contrat"))) - DimMinus
        colonnePCCOSuffixe = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_input_CTF"))) - DimMinus
        colonnePCECReporting = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_PCECReporting"))) - DimMinus
        colonnePECEC_Calcule = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_PCEC_Calcule"))) - DimMinus
        colonneTopIntExt = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_TopIntExt"))) - DimMinus
        colonneZoneFiscale = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_ZoneFiscale"))) - DimMinus
        colonneFamCoeffTax = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_FamCoeffTax"))) - DimMinus
        colonneMethodClcCoeffTax = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_MethodClcCoeffTax"))) - DimMinus
        colonneSuccursale = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_Succursale"))) - DimMinus
        colonneGTVA = DictInputArrRstAndLabel(CStr(.Range("rng_mapping_GTVA"))) - DimMinus
    End With

    'Préparation dict somme montant par unicité des categories (n°contrat non utilisable comme clé)
    For i = LBound(ArrayInput, 1) To UBound(ArrayInput, 1)
    
        KeyTemp = FctFillIfEmpty(ArrayInput(i, colonnePCCOSuffixe)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonnePCECReporting)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonnePECEC_Calcule))

        KeyInput = FctFillIfEmpty(ArrayInput(i, colonneTopIntExt)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonneZoneFiscale)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonneFamCoeffTax)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonneMethodClcCoeffTax)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonneSuccursale)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonneGTVA)) & "__" & _
                    FctFillIfEmpty(ArrayInput(i, colonneTypeContrat))

        If Not DictContract.Exists(KeyInput) Then
            DictContract.Add KeyInput, CDbl(ArrayInput(i, colonneAmount))
            DictTemp.Add CStr(KeyInput), KeyTemp
        ElseIf DictContract.Exists(KeyInput) Then
            DictContract.Item(KeyInput) = DictContract.Item(KeyInput) + ArrayInput(i, colonneAmount)
        End If
    Next i
    
    'Filtre récuperation seulement des contrats dont le montant<0
    count = 0
    For Each KeyDict In DictContract.Keys
        If DictContract(KeyDict) < 0 Then
            DictContractUnique.Add KeyDict, DictContract(KeyDict)
            count = count + 1
        End If
    Next KeyDict
    
    'Optimisation ram
    Set DictContract = Nothing
    
    ReDim ArrayTempFiltered(1 To count + 1, 1 To 11)
    
    'Récupération des titres
    For j = 1 To 10
        With ws_mapping
            KeyInputLabel = DictLabelMapping(CStr(.Range("rng_mapping_input_CTF"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_PCECReporting"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_PCEC_Calcule"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_TopIntExt"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_ZoneFiscale"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_FamCoeffTax"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_MethodClcCoeffTax"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_Succursale"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_GTVA"))) & "__" & _
                            DictLabelMapping(CStr(.Range("rng_mapping_contrat")))
        End With
        ArrayTempFiltered(1, j) = Split(KeyInputLabel, "__")(j - 1)
    Next j
    ArrayTempFiltered(1, 11) = DictLabelMapping.Item(CStr(ws_mapping.Range("rng_mapping_InputAmount")))

    'Optimisation ram
    Erase ArrayInput
    
    'Remplissage de la variable ArrayInput résultat
    i = 2
    For Each KeyDict In DictContractUnique.Keys
        'pour champ  clé mapping
        For j = 1 To UBound(Split(KeyDict, "__")) + 1
            StrValue = Split(KeyDict, "__")(j - 1)
            If StrValue = "empty" Then StrValue = ""
            ArrayTempFiltered(i, 3 + j) = StrValue
        Next j
        'pour champ non clé mapping
        KeyDictTemp = DictTemp.Item(KeyDict)
        For j = 1 To UBound(Split(KeyDictTemp, "__")) + 1
            StrValue = Split(KeyDictTemp, "__")(j - 1)
            ArrayTempFiltered(i, j) = StrValue
        Next j
        'on récupère le montant
        ArrayTempFiltered(i, 11) = Abs(DictContractUnique(KeyDict))
        i = i + 1
    Next KeyDict
    
    Set DictTemp = Nothing
    Set DictContractUnique = Nothing
    ImportIfatMethodArray = ArrayTempFiltered
    Erase ArrayTempFiltered

End Function

'================================================================================================================='
'================================================TOOLS IMPORT====================================================='
'================================================================================================================='

'=================================================TOOLS SQL======================================================='

'Préparation de l'import CSV IFAT par méthode CSV
Function FctGetDictInputArrRstAndLabel(TypeImport As String, FullPath As String, DictLabelMapping As Dictionary, Optional BoolNoStockRst As Boolean) As Dictionary

    'Necessite :
    'Microsoft ActiveX Data Objects
    'Microsoft ADO  pour DDL et sécurité.

    Dim cn                  As New ADODB.Connection
    Dim rst                 As ADODB.Recordset
    Dim objCat              As ADOX.Catalog
    Dim ShtName             As ADOX.Table
    Dim ArrayRst            As Variant
    Dim ArrayRst1           As Variant
    Dim DictLabelRst        As New Dictionary
    Dim DictTemp            As New Dictionary
    Dim StrRep              As String
    Dim strFile             As String
    Dim ListSelectLabelSql  As String
    Dim ShtTable            As String
    Dim i                   As Long
    
    StrRep = Left(FullPath, InStrRev(FullPath, Application.PathSeparator))
    strFile = Dir(FullPath)
    
    If TypeImport = "csv" Then 'Modification du fichier ini CSV
        Call FctModifyShemaIniCsv(StrRep, strFile, "Delimited(;)")
    End If
    
    Set rst = New ADODB.Recordset
    With cn
        If TypeImport = "csv" Then
            'connexion à la base de  données (votre StrFile CSV)
            .Open "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & StrRep & ";Extended Properties=""Text;HDR=YES;FMT=Delimited(;)"""
        ElseIf TypeImport = "xlsx" Then
            .Open "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & FullPath & ";Extended Properties=""Excel 12.0; HDR=YES; IMEX=1""; Mode=Read;"
        End If
        
        If BoolNoStockRst = True Then
            'Pour Check champs
            ListSelectLabelSql = "TOP 1 * " & ListSelectLabelSql
        Else
            'Récupération des champs
            ListSelectLabelSql = FctListSelectLabelSql(DictLabelMapping)
        End If
        
        If TypeImport = "csv" Then
            Set rst = .Execute("Select " & ListSelectLabelSql & " from [" & Replace(strFile, ".", "#") & "]")
        ElseIf TypeImport = "xlsx" Then
            Set objCat = New ADOX.Catalog
            Set objCat.ActiveConnection = cn
            For Each ShtName In objCat.Tables
                DictTemp.Add ShtName.name, ""
            Next
            ShtTable = FctAdoGetShtName(DictTemp)
            Set rst = .Execute("Select  * " & " from [" & ShtTable & "] ")
        End If
        
        'on stock la variable tableau dans dictionnaire
        If BoolNoStockRst = False Then 'par défaut
            ArrayRst = rst.GetRows
            ArrayRst = FctTransposeArrayStr(ArrayRst)
            DictLabelRst.Add "ArrayRst", ArrayRst
        End If
        'on stock les labels associé à leurs numeros de colonnes
        For i = 0 To rst.Fields.count - 1
             DictLabelRst.Add CStr(rst(i).name), i + 1
        Next
        'call FctDisplayRst(rst,ws_test)
        rst.Close
        .Close
    End With
    
    Set cn = Nothing
    Set objCat = Nothing
    Set rst = Nothing
    
    Set FctGetDictInputArrRstAndLabel = DictLabelRst
    Set DictLabelRst = Nothing
    Set DictTemp = Nothing
    
End Function

'Modification  base de registre du fichier Schema.ini dans le répertoire qui contient le CSV (car ADODB csv USA ',')
Function FctModifyShemaIniCsv(ByVal Server As String, Fichier As String, Delimited As String)

    Dim txt As String
    If Right(Server, 1) <> "\" Then Server = Server & "\"
    txt = "[" & Fichier & "]" & vbCrLf & "Format= " & Delimited
    With CreateObject("Scripting.FileSystemObject")
        With .OpenTextFile(Server & "Schema.ini", 2, True)
            .Write txt
            .Close
        End With
    End With

End Function

'Récupération du nom correct de la feuille d'un fichier .xlsx par ADO
Function FctAdoGetShtName(DictTemp As Dictionary) As String
    Dim KeyDict As Variant
    Select Case DictTemp.count
        Case 1
            For Each KeyDict In DictTemp.Keys
                FctAdoGetShtName = CStr(KeyDict)
            Next KeyDict
        Case 2
            For Each KeyDict In DictTemp.Keys
                If InStr(CStr(KeyDict), "xlnm") = 0 Then
                    FctAdoGetShtName = CStr(KeyDict)
                End If
            Next KeyDict
        Case 3
            For Each KeyDict In DictTemp.Keys
                If InStr(CStr(KeyDict), "xlnm") = 0 And InStr(CStr(KeyDict), "Feuil1$") = 0 Then
                    FctAdoGetShtName = CStr(KeyDict)
                End If
            Next KeyDict
        Case Else
            MsgBox "Input xlsx a plus d'une feuille, impossible de déterminer l'importe, veuillez laissé qu'une seule feuille", vbCritical, "Import Data xlsx"
    End Select
    If Not Right(FctAdoGetShtName, 1) = "$" Then
        FctAdoGetShtName = FctAdoGetShtName & "$"
    End If
    
End Function

Function FctListSelectLabelSql(DicoLabelMapping As Dictionary) As String

    Dim KeyDict             As Variant
    Dim StrLabel            As String

    For Each KeyDict In DicoLabelMapping.Keys
        StrLabel = StrLabel & "[" & CStr(KeyDict) & "], "
    Next KeyDict

    FctListSelectLabelSql = FctDelComa(StrLabel)

End Function

Function FctDelComa(StrLabel As String) As String
    'suppresion la virgule finale
    If Right(StrLabel, 2) = ", " Then
        StrLabel = Left(StrLabel, Len(StrLabel) - 2)
    End If
    FctDelComa = StrLabel
End Function

Function FctDisplayRst(rst As ADODB.Recordset, Optional sht As Worksheet)
    If IsMissing(sht) Then
        For i = 0 To rst.Fields.count - 1
             ActiveSheet.Range("A1").Offset(, i) = rst(i).name
        Next i
        'Range("A2").Resize(UBound(ArrayRst, 1), UBound(ArrayRst, 2) + 1).value = ArrayRst
        ActiveCell.Range("A2").CopyFromRecordset rst
    Else
        For i = 0 To rst.Fields.count - 1
             sht.Range("A1").Offset(, i) = rst(i).name
        Next i
        sht.Range("A2").CopyFromRecordset rst
    End If
End Function

'=================================================TOOLS MAPPING======================================================='

'Récupération des labels mapping
Public Function FctLoadDictLabel(ByVal StartCellTemp As String, ByVal array_type As String, Optional type_label As String) As Dictionary

    Dim MyArray     As Variant
    Dim DictArray   As Dictionary
    Dim LastCol     As Long
    Dim LastRow     As Long
    Dim x           As Integer
    Dim count       As Integer
    
    Set DictArray = New Dictionary
    count = 1
    If array_type = "v" Then
        With ws_mapping
            LastRow = .Range(StartCellTemp).End(xlDown).row
            LastCol = .Range(StartCellTemp).Column + 1
            MyArray = .Range(StartCellTemp & ":" & FctColLetter(LastCol) & LastRow)
        End With
        For x = LBound(MyArray, 1) To UBound(MyArray, 1)
            If Not DictArray.Exists(MyArray(x, 1)) Then
                DictArray.Add MyArray(x, 1), MyArray(x, 2)
            End If
            count = count + 1
        Next x
    ElseIf array_type = "h" Then
        Select Case type_label
            Case "mapping"
                With ws_mapping
                    LastCol = .Cells(.Range(StartCellTemp).row, .Range(StartCellTemp).Column).End(xlToRight).Column
                    LastRow = .Cells(.Rows.count, .Range(StartCellTemp).Column).End(xlUp).row
                    MyArray = .Range(StartCellTemp & ":" & FctColLetter(LastCol) & LastRow)
                End With
            Case "input_CTF"
                With ws_input_CTF
                    LastCol = .Cells(.Range(StartCellTemp).row, .Columns.count).End(xlToLeft).Column
                    LastRow = .Cells(.Rows.count, .Range(StartCellTemp).Column).End(xlUp).row
                    MyArray = .Range(StartCellTemp & ":" & FctColLetter(LastCol) & LastRow)
                End With
            Case "input_ifac"
                With ws_input_ifac
                    LastCol = .Cells(.Range(StartCellTemp).row, .Columns.count).End(xlToLeft).Column
                    LastRow = .Cells(.Rows.count, .Range(StartCellTemp).Column).End(xlUp).row
                    MyArray = .Range(StartCellTemp & ":" & FctColLetter(LastCol) & LastRow)
                End With
        End Select
        For x = LBound(MyArray, 2) To UBound(MyArray, 2)
            If Not DictArray.Exists(MyArray(1, x)) Then
                DictArray.Add CStr(MyArray(1, x)), count
            End If
            count = count + 1
        Next
    End If
    
    Set FctLoadDictLabel = DictArray
    Set DictArray = Nothing
    Set MyArray = Nothing
    
End Function

Function FctCheckFilters(amount As Variant) As Boolean

    FctCheckFilters = False
    If amount > 0 Then
        FctCheckFilters = True
     Else
        FctCheckFilters = False
    End If
    
End Function

'=================================================TOOLS CHECK ======================================================='

Function FctCheckLabelInput(TypeInput As String, FileName As String, DictLabelMapping As Dictionary) As Boolean

    Dim KeyDict             As Variant
    Dim DictLabelMissed     As New Dictionary
    Dim DictInputLabel      As Dictionary
    Dim MsgLabelMissed      As String
    Dim BoolLabelMissed     As Boolean
    
    Set DictInputLabel = FctGetDictInputArrRstAndLabel(TypeInput, FileName, DictLabelMapping, True)
    BoolLabelMissed = False
    For Each KeyDict In DictLabelMapping.Keys
        If Not KeyDict = ws_mapping.Range("rng_mapping_contrat") Then
            If Not DictInputLabel.Exists(CStr(KeyDict)) Then
                BoolLabelMissed = True
                DictLabelMissed.Add CStr(KeyDict), ""
            End If
        End If
    Next KeyDict

    If BoolLabelMissed = True Then
        FctCheckLabelInput = False
        For Each KeyDict In DictLabelMissed.Keys
            MsgLabelMissed = MsgLabelMissed & KeyDict & ", "
        Next
        If Right(MsgLabelMissed, 2) = ", " Then
            MsgLabelMissed = Left(MsgLabelMissed, Len(MsgLabelMissed) - 2)
        End If
        
        MsgBox "veuillez vérifier le mapping, pour l'import" & Dir(FileName) & Chr(13) & Chr(10) & "Les champs suivants ne sont pas retrouvés" & Chr(13) & Chr(10) & Chr(10) & MsgLabelMissed _
        & Chr(13) & Chr(10) & Chr(10) & "Veuillez les ajouter ou modifier le mapping, les champs doivent etre identiques pour tous les inputs", _
        vbCritical, "Error on Label Mapping for File Import  :" & Dir(FileName)
    Else
        FctCheckLabelInput = True
    End If
    
    Set DictLabelMissed = Nothing
    Set DictInputLabel = Nothing
    
End Function

Function FctCheckRep(PathTemp As String) As String

    If Not Right(PathTemp, 1) = "\" Then
        FctCheckRep = PathTemp & "\"
    Else
        FctCheckRep = PathTemp
    End If
    
End Function

Function ClearData(WsNameTemp As String, StartCellTemp As String, NumMethod As Byte)

    Dim WsResult   As Worksheet
    Dim RngData    As Range
    Dim LastCol    As Long
    Dim LastRow    As Long
    
    Set WsResult = Workbooks(CStr(ThisWorkbook.name)).Worksheets(WsNameTemp)
    With WsResult
        Select Case NumMethod
            Case 1
                Set RngData = .Range(.Range(StartCellTemp), .Range(StartCellTemp).End(xlDown))
                Set RngData = .Range(RngData, RngData.End(xlToRight))
                RngData.Clear
                Set RngData = Nothing
            Case 2
                LastCol = .Cells(.Range(StartCellTemp).row, .Columns.count).End(xlToLeft).Column
                LastRow = .Cells(.Rows.count, .Range(StartCellTemp).Column).End(xlUp).row
                .Range(StartCellTemp & ":" & FctColLetter(LastCol) & LastRow).Clear
            Case 3
                LastCol = .Range(StartCellTemp).Offset(-1, 0).End(xlToRight).Column
                LastRow = .Range(StartCellTemp).Offset(0, -2).End(xlDown).row
                .Range(.Range(StartCellTemp), .Cells(LastRow, LastCol)).ClearContents
            Case 4
                .Cells.ClearContents
        End Select
    End With
    
End Function

'=================================================TOOLS ======================================================='

Function FctTransposeArrayVar(InputArray As Variant) As Variant

    Dim tmp()   As Variant
    Dim i       As Long
    Dim j       As Long
    
    ReDim tmp(LBound(InputArray, 2) To UBound(InputArray, 2), LBound(InputArray, 1) To UBound(InputArray, 1))
    
    For i = LBound(InputArray, 2) To UBound(InputArray, 2)
        For j = LBound(InputArray, 1) To UBound(InputArray, 1)
            If IsNull(InputArray(j, i)) Then
                tmp(i, j) = ""
            Else
                tmp(i, j) = InputArray(j, i)
            End If
        Next j
    Next i
    FctTransposeArrayVar = tmp
    Erase tmp
    
End Function

Function FctTransposeArrayStr(InputArray As Variant) As String()

    Dim tmp() As String
    Dim i       As Long
    Dim j       As Long

    ReDim tmp(LBound(InputArray, 2) To UBound(InputArray, 2), LBound(InputArray, 1) To UBound(InputArray, 1))
    For i = LBound(InputArray, 1) To UBound(InputArray, 1)
        For j = LBound(InputArray, 2) To UBound(InputArray, 2)
            If Not IsNull(InputArray(i, j)) Then
                tmp(j, i) = InputArray(i, j)
            End If
        Next j
    Next i
    FctTransposeArrayStr = tmp
    Erase tmp
    
End Function

'Non utilisé (en veille)
Function FctGetKeyDict(Dic As Dictionary, str_item As Variant) As String

    Dim key As Variant
    For Each key In Dic.Keys
        If Dic.Item(key) = str_item Then
            FctGetKeyDict = CStr(key)
            Exit Function
        End If
    Next
    If FctGetKeyDict = "" Then FctGetKeyDict = ""
       
End Function

'Non utilisé (en veille)
Sub FctSplitCsv(FullPath As String)
    
    Dim FSO     As Object
    Dim csv     As Object
    Dim header  As Variant
    Dim maxRows As Variant
    Dim i       As Variant
    Dim n       As Variant
    Dim out     As Variant
    Dim StrRep  As String
    
    maxRows = 150000
    StrRep = Left(FullPath, InStrRev(FullPath, Application.PathSeparator))
    Const ForReading = 1
    Const ForWriting = 2
    Set FSO = CreateObject("Scripting.FileSystemObject")
    i = 0
    n = 0
    Set out = Nothing
    Set csv = FSO.OpenTextFile(FullPath, ForReading)
    header = csv.ReadLine
    
    Do Until csv.AtEndOfStream
      If i = 0 Then
        If Not out Is Nothing Then out.Close
        Set out = FSO.CreateTextFile(StrRep & "SplitCsv_" & Right("00" & n, 2) & ".csv", ForWriting)
        out.WriteLine (header)
        n = n + 1
      End If
      out.WriteLine (csv.ReadLine)
      i = (i + 1) Mod maxRows
    Loop
    csv.Close
    If Not out Is Nothing Then out.Close

End Sub
