
Public Sub MedianThreeQuickSort1_2D_Asc_Optimized(ByRef pvarArray As Variant, _
                                                  ByVal iCol As Integer, _
                                                  Optional ByVal BoolTitle As Boolean = False, _
                                                  Optional ByVal plngLeft As Long, _
                                                  Optional ByVal plngRight As Long)

    Dim j As Long
    Dim stack() As Long
    Dim top As Long
    Dim lngFirst As Long
    Dim lngLast As Long
    Dim varMid As Variant
    Dim lngIndex As Long
    Dim varSwap As Variant
    Dim a As Long, b As Long, c As Long
    Dim tempLeft As Long, tempRight As Long

    ' Initialisation des bornes du tri
    If plngRight = 0 Then
        plngLeft = LBound(pvarArray, 1)
        plngRight = UBound(pvarArray, 1)
        If BoolTitle Then plngLeft = plngLeft + 1 ' Ignorer la première ligne si BoolTitle est vrai
    End If

    ' Allocation de la pile pour le tri itératif (évite la récursion)
    ReDim stack(1 To plngRight - plngLeft + 1)
    top = 1
    stack(top) = plngLeft
    top = top + 1
    stack(top) = plngRight

    ' Boucle itérative pour simuler la récursion
    Do While top > 0
        ' Extraire les limites actuelles de la pile
        tempRight = stack(top)
        top = top - 1
        tempLeft = stack(top)
        top = top - 1
        
        lngFirst = tempLeft
        lngLast = tempRight
        lngIndex = tempRight - tempLeft + 1

        ' Choix du pivot (médiane de trois pour réduire la probabilité des mauvais pivots)
        a = tempLeft + Int(lngIndex * Rnd)
        b = tempLeft + Int(lngIndex * Rnd)
        c = tempLeft + Int(lngIndex * Rnd)

        ' Choix du pivot en utilisant la médiane de trois
        If pvarArray(a, iCol) < pvarArray(b, iCol) Then
            If pvarArray(b, iCol) < pvarArray(c, iCol) Then
                lngIndex = b ' b est le pivot
            ElseIf pvarArray(a, iCol) < pvarArray(c, iCol) Then
                lngIndex = c ' c est le pivot
            Else
                lngIndex = a ' a est le pivot
            End If
        Else
            If pvarArray(a, iCol) < pvarArray(c, iCol) Then
                lngIndex = a ' a est le pivot
            ElseIf pvarArray(b, iCol) < pvarArray(c, iCol) Then
                lngIndex = c ' c est le pivot
            Else
                lngIndex = b ' b est le pivot
            End If
        End If

        varMid = pvarArray(lngIndex, iCol)

        ' Partitionnement des données (ordre croissant)
        Do
            Do While lngFirst < plngRight And pvarArray(lngFirst, iCol) < varMid
                lngFirst = lngFirst + 1
            Loop
            Do While lngLast > plngLeft And varMid < pvarArray(lngLast, iCol)
                lngLast = lngLast - 1
            Loop
            
            ' Échanger les lignes si nécessaire
            If lngFirst <= lngLast Then
                For j = LBound(pvarArray, 2) To UBound(pvarArray, 2)
                    varSwap = pvarArray(lngLast, j)
                    pvarArray(lngLast, j) = pvarArray(lngFirst, j)
                    pvarArray(lngFirst, j) = varSwap
                Next j
                lngFirst = lngFirst + 1
                lngLast = lngLast - 1
            End If
        Loop Until lngFirst > lngLast

        ' Pousser les partitions sur la pile pour trier
        If tempLeft < lngLast Then
            top = top + 1
            stack(top) = tempLeft
            top = top + 1
            stack(top) = lngLast
        End If
        If lngFirst < tempRight Then
            top = top + 1
            stack(top) = lngFirst
            top = top + 1
            stack(top) = tempRight
        End If
    Loop
End Sub

Public Sub MedianThreeQuickSort1_2D_Desc_Optimized(ByRef pvarArray As Variant, _
                                                  ByVal iCol As Integer, _
                                                  Optional ByVal BoolTitle As Boolean = False, _
                                                  Optional ByVal plngLeft As Long, _
                                                  Optional ByVal plngRight As Long)
    
    Dim j As Long
    Dim stack() As Long
    Dim top As Long
    Dim lngFirst As Long
    Dim lngLast As Long
    Dim varMid As Variant
    Dim lngIndex As Long
    Dim varSwap As Variant
    Dim a As Long, b As Long, c As Long
    Dim tempLeft As Long, tempRight As Long
    
    ' Initialisation des bornes du tri
    If plngRight = 0 Then
        plngLeft = LBound(pvarArray, 1)
        plngRight = UBound(pvarArray, 1)
        If BoolTitle Then plngLeft = plngLeft + 1 ' Ignorer la première ligne si BoolTitle est vrai
    End If

    ' Allocation de la pile pour le tri itératif (évite la récursion)
    ReDim stack(1 To plngRight - plngLeft + 1)
    top = 1
    stack(top) = plngLeft
    top = top + 1
    stack(top) = plngRight

    ' Boucle itérative pour simuler la récursion
    Do While top > 0
        ' Extraire les limites actuelles de la pile
        tempRight = stack(top)
        top = top - 1
        tempLeft = stack(top)
        top = top - 1
        
        lngFirst = tempLeft
        lngLast = tempRight
        lngIndex = tempRight - tempLeft + 1
        
        ' Choix du pivot (médiane de trois pour réduire la probabilité des mauvais pivots)
        a = tempLeft + Int(lngIndex * Rnd)
        b = tempLeft + Int(lngIndex * Rnd)
        c = tempLeft + Int(lngIndex * Rnd)

        If pvarArray(a, iCol) <= pvarArray(b, iCol) And pvarArray(b, iCol) <= pvarArray(c, iCol) Then
            lngIndex = b
        ElseIf pvarArray(b, iCol) <= pvarArray(a, iCol) And pvarArray(a, iCol) <= pvarArray(c, iCol) Then
            lngIndex = a
        Else
            lngIndex = c
        End If

        varMid = pvarArray(lngIndex, iCol)
        
        ' Partitionnement des données (ordre décroissant)
        Do
            Do While pvarArray(lngFirst, iCol) > varMid
                lngFirst = lngFirst + 1
            Loop
            Do While varMid > pvarArray(lngLast, iCol)
                lngLast = lngLast - 1
            Loop
            
            ' Échanger les lignes si nécessaire
            If lngFirst <= lngLast Then
                For j = LBound(pvarArray, 2) To UBound(pvarArray, 2)
                    varSwap = pvarArray(lngLast, j)
                    pvarArray(lngLast, j) = pvarArray(lngFirst, j)
                    pvarArray(lngFirst, j) = varSwap
                Next j
                lngFirst = lngFirst + 1
                lngLast = lngLast - 1
            End If
        Loop Until lngFirst > lngLast

        ' Pousser les partitions sur la pile pour trier
        If tempLeft < lngLast Then
            top = top + 1
            stack(top) = tempLeft
            top = top + 1
            stack(top) = lngLast
        End If
        If lngFirst < tempRight Then
            top = top + 1
            stack(top) = lngFirst
            top = top + 1
            stack(top) = tempRight
        End If
    Loop
    
'Explication des optimisations :
'Itération au lieu de récursion :

'Plutôt que d'utiliser des appels récursifs qui peuvent entraîner une surcharge de la pile, le tri est implémenté de manière itérative à l'aide d'une pile manuelle (stack) pour gérer les limites du sous-tableau à trier. Cela réduit considérablement le risque de dépassement de la pile lorsque les données à trier sont volumineuses.
'Pivot optimisé (médiane de trois) :

'Le choix du pivot est toujours basé sur la médiane de trois, mais on peut réduire les comparaisons avec un algorithme plus direct. Le bon choix du pivot réduit la probabilité que l'algorithme de tri ait des performances quadratiques (O(n²)).
'Réduction des comparaisons :

'Les boucles de tri comparent uniquement les éléments pertinents et arrêtent les itérations dès qu'une condition est satisfaite. Cela évite les comparaisons redondantes.
''Échange minimal des valeurs :
'Lors de l’échange des lignes, on ne le fait que si c’est absolument nécessaire, évitant ainsi des copies de données coûteuses.
End Sub


Public Sub MedianThreeQuickSort1_2D_Desc(ByRef pvarArray As Variant, _
                                        ByVal iCol As Integer, _
                                            Optional ByVal BoolTitle As Boolean = False, _
                                                Optional ByVal plngLeft As Long, _
                                                    Optional ByVal plngRight As Long)
' Tri par QuickSort en ordre décroissant avec option d'ignorer la première ligne (titres)
' BoolTitle : Si vrai, ignore la première ligne du tableau (les titres)
' NOTE: routine récursive, ne pas fournir plngLeft & plngRight à l'appel initial. Ils sont utilisés en interne.

    Dim j As Integer
    Dim lngFirst As Long
    Dim lngLast As Long
    Dim varMid As Variant
    Dim lngIndex As Long
    Dim varSwap As Variant
    Dim a As Long
    Dim b As Long
    Dim c As Long
    
    ' Si plngRight vaut 0, initialisation des bornes de tri
    If plngRight = 0 Then
        plngLeft = LBound(pvarArray, 1)
        plngRight = UBound(pvarArray, 1)
        ' Si BoolTitle est vrai, ignorer la première ligne
        If BoolTitle Then
            plngLeft = plngLeft + 1
        End If
    End If
    
    lngFirst = plngLeft
    lngLast = plngRight
    lngIndex = plngRight - plngLeft + 1
    
    ' Sélection aléatoire de trois indices pour choisir le pivot
    a = Int(lngIndex * Rnd) + plngLeft
    b = Int(lngIndex * Rnd) + plngLeft
    c = Int(lngIndex * Rnd) + plngLeft
    
    ' Choix du pivot (médiane de trois)
    If pvarArray(a, iCol) <= pvarArray(b, iCol) And pvarArray(b, iCol) <= pvarArray(c, iCol) Then
        lngIndex = b
    ElseIf pvarArray(b, iCol) <= pvarArray(a, iCol) And pvarArray(a, iCol) <= pvarArray(c, iCol) Then
        lngIndex = a
    Else
        lngIndex = c
    End If
    
    varMid = pvarArray(lngIndex, iCol)
    
    ' Boucle principale pour le tri par partitionnement en ordre décroissant
    Do
        Do While pvarArray(lngFirst, iCol) > varMid And lngFirst < plngRight
            lngFirst = lngFirst + 1
        Loop
        Do While varMid > pvarArray(lngLast, iCol) And lngLast > plngLeft
            lngLast = lngLast - 1
        Loop
        
        ' Échange des lignes si nécessaire
        If lngFirst <= lngLast Then
            For j = LBound(pvarArray, 2) To UBound(pvarArray, 2)
                varSwap = pvarArray(lngLast, j)
                pvarArray(lngLast, j) = pvarArray(lngFirst, j)
                pvarArray(lngFirst, j) = varSwap
            Next j
            
            lngFirst = lngFirst + 1
            lngLast = lngLast - 1
        End If
    Loop Until lngFirst > lngLast
    
    ' Appels récursifs pour trier les partitions gauche et droite
    If (lngLast - plngLeft) < (plngRight - lngFirst) Then
        If plngLeft < lngLast Then MedianThreeQuickSort1_2D_Desc pvarArray, iCol, BoolTitle, plngLeft, lngLast
        If lngFirst < plngRight Then MedianThreeQuickSort1_2D_Desc pvarArray, iCol, BoolTitle, lngFirst, plngRight
    Else
        If lngFirst < plngRight Then MedianThreeQuickSort1_2D_Desc pvarArray, iCol, BoolTitle, lngFirst, plngRight
        If plngLeft < lngLast Then MedianThreeQuickSort1_2D_Desc pvarArray, iCol, BoolTitle, plngLeft, lngLast
    End If
End Sub



 
 
 Sub MedianThreeQuickSort1_2D_Asc(ByRef pvarArray As Variant, _
                                        ByVal iCol As Integer, _
                                            Optional ByVal BoolTitle As Boolean = False, _
                                                Optional ByVal plngLeft As Long, _
                                                    Optional ByVal plngRight As Long)
' Tri par QuickSort utilisant la médiane de trois, avec option d'ignorer la première ligne (titres)
' BoolTitle : Si vrai, ignore la première ligne du tableau (les titres)
' NOTE: routine récursive, ne pas fournir plngLeft & plngRight à l'appel initial. Ils sont utilisés en interne.

    Dim j As Integer
    Dim lngFirst As Long
    Dim lngLast As Long
    Dim varMid As Variant
    Dim lngIndex As Long
    Dim varSwap As Variant
    Dim a As Long
    Dim b As Long
    Dim c As Long
    
    ' Si plngRight vaut 0, initialisation des bornes de tri
    If plngRight = 0 Then
        plngLeft = LBound(pvarArray, 1)
        plngRight = UBound(pvarArray, 1)
        ' Si BoolTitle est vrai, ignorer la première ligne
        If BoolTitle Then
            plngLeft = plngLeft + 1
        End If
    End If
    
    lngFirst = plngLeft
    lngLast = plngRight
    lngIndex = plngRight - plngLeft + 1
    
    ' Sélection aléatoire de trois indices pour choisir le pivot
    a = Int(lngIndex * Rnd) + plngLeft
    b = Int(lngIndex * Rnd) + plngLeft
    c = Int(lngIndex * Rnd) + plngLeft
    
    ' Choix du pivot (médiane de trois)
    If pvarArray(a, iCol) <= pvarArray(b, iCol) And pvarArray(b, iCol) <= pvarArray(c, iCol) Then
        lngIndex = b
    ElseIf pvarArray(b, iCol) <= pvarArray(a, iCol) And pvarArray(a, iCol) <= pvarArray(c, iCol) Then
        lngIndex = a
    Else
        lngIndex = c
    End If
    
    varMid = pvarArray(lngIndex, iCol)
    
    ' Boucle principale pour le tri par partitionnement
    Do
        Do While pvarArray(lngFirst, iCol) < varMid And lngFirst < plngRight
            lngFirst = lngFirst + 1
        Loop
        Do While varMid < pvarArray(lngLast, iCol) And lngLast > plngLeft
            lngLast = lngLast - 1
        Loop
        
        ' Échange des lignes si nécessaire
        If lngFirst <= lngLast Then
            For j = LBound(pvarArray, 2) To UBound(pvarArray, 2)
                varSwap = pvarArray(lngLast, j)
                pvarArray(lngLast, j) = pvarArray(lngFirst, j)
                pvarArray(lngFirst, j) = varSwap
            Next j
            
            lngFirst = lngFirst + 1
            lngLast = lngLast - 1
        End If
    Loop Until lngFirst > lngLast
    
    ' Appels récursifs pour trier les partitions gauche et droite
    If (lngLast - plngLeft) < (plngRight - lngFirst) Then
        If plngLeft < lngLast Then MedianThreeQuickSort1_2D_Asc pvarArray, iCol, BoolTitle, plngLeft, lngLast
        If lngFirst < plngRight Then MedianThreeQuickSort1_2D_Asc pvarArray, iCol, BoolTitle, lngFirst, plngRight
    Else
        If lngFirst < plngRight Then MedianThreeQuickSort1_2D_Asc pvarArray, iCol, BoolTitle, lngFirst, plngRight
        If plngLeft < lngLast Then MedianThreeQuickSort1_2D_Asc pvarArray, iCol, BoolTitle, plngLeft, lngLast
    End If
End Sub


Public Sub TestSortWithTimer()

    Dim pvarArray As Variant
    Dim i As Long, j As Long
    Dim nbRows As Long
    Dim nbCols As Long
    Dim startTime As Double
    Dim endTime As Double
    Dim ws As Worksheet

    ' Paramètres du jeu de données
    nbRows = 1000    ' Nombre de lignes de données (hors titres)
    nbCols = 5       ' Nombre de colonnes de données

    ' Créer un nouveau jeu de données sur la feuille active
    Set ws = ThisWorkbook.Sheets.Add
    ws.Name = "TestData"
    
    ' Ajouter les titres sur la première ligne
    For j = 1 To nbCols
        ws.Cells(1, j).Value = "Colonne " & j
    Next j
    
    ' Remplir les cellules de données avec des valeurs aléatoires
    For i = 2 To nbRows + 1
        For j = 1 To nbCols
            ws.Cells(i, j).Value = Int((1000 - 1 + 1) * Rnd + 1) ' Nombres aléatoires entre 1 et 1000
        Next j
    Next i

    ' Mettre les données dans un tableau 2D
    pvarArray = ws.Range(ws.Cells(1, 1), ws.Cells(nbRows + 1, nbCols)).Value

    ' Lancer le timer pour mesurer le temps d'exécution du tri
    startTime = Timer
    
    ' Appliquer la fonction de tri sur la 3ème colonne en ignorant les titres
    Call MedianThreeQuickSort1_2D_Desc(pvarArray, 3, True)
    
    ' Arrêter le timer après le tri
    endTime = Timer
    
    ' Remettre le tableau trié sur la feuille
    With Worksheets("delta")
    
    .Range(.Cells(1, 1), .Cells(nbRows + 1, nbCols)).Value = pvarArray
    End With

    ' Afficher le temps d'exécution dans une boîte de message
    MsgBox "Le tri a pris " & Format(endTime - startTime, "0.00") & " secondes.", vbInformation
End Sub

