
risk_cmt et front_cmt depuis une feuille interface vers la base FLUX (clé unique (Booking, NDC)) et ARCHIVE (au choix : dernier épisode ou tous).
C’est full set-based (aucune boucle VBA), très rapide, souple (entêtes paramétrables) et n’écrase pas avec du vide.

Sub PushComments()
    Dim cn As ADODB.Connection
    Set cn = GetConn(ThisWorkbook.Path & Application.PathSeparator & DB_NAME)
    EnsureCommentColumns cn  ' <-- au cas où la base existe déjà sans ces 3 colonnes
    ' Met à jour FLUX + le DERNIER enregistrement ARCHIVE par (Booking, NDC)
    UpdateRiskFrontFromInterface cn, Worksheets("Interface"), "Latest", _
                                 "Booking", "NO DOSSIER CREDIT", "risk_cmt", "front_cmt"
    cn.Close
End Sub


ArchiveMode :

"Latest" : met à jour uniquement la ligne d’Archive la plus récente par clé.

"All" : met à jour toutes les lignes d’Archive correspondant à la clé.

Les entêtes Booking, NO DOSSIER CREDIT, risk_cmt, front_cmt sont paramétrables si ta feuille utilise d’autres libellés.



Le code (copie-colle tel quel)
' ===========================================================
'   MàJ risk_cmt / front_cmt depuis une feuille "interface"
'   -> T_Flux (clé Booking+NDC)
'   -> T_Archive (dernier épisode par clé OU toutes les lignes)
'   - Full set-based (UPDATE ... JOIN Excel), ultra-rapide
'   - N’écrase pas par des blancs (on met à jour si non vide)
' ===========================================================

Public Sub UpdateRiskFrontFromInterface( _
    ByVal cn As ADODB.Connection, _
    ByVal ws As Worksheet, _
    Optional ByVal ArchiveMode As String = "Latest", _
    Optional ByVal BookingHdr As String = "Booking", _
    Optional ByVal NDCHdr As String = "NO DOSSIER CREDIT", _
    Optional ByVal RiskHdr As String = "risk_cmt", _
    Optional ByVal FrontHdr As String = "front_cmt" _
)
    ' --- validations minimales sur les entêtes ---
    If FindHeader(ws, BookingHdr) = 0 Then Err.Raise vbObjectError + 2101, , "Colonne introuvable : " & BookingHdr
    If FindHeader(ws, NDCHdr) = 0 Then Err.Raise vbObjectError + 2102, , "Colonne introuvable : " & NDCHdr
    Dim hasRisk As Boolean, hasFront As Boolean
    hasRisk = (FindHeader(ws, RiskHdr) > 0)
    hasFront = (FindHeader(ws, FrontHdr) > 0)
    If Not (hasRisk Or hasFront) Then Exit Sub  ' rien à pousser

    ' --- référence ACE vers la plage Excel bornée à UsedRange (HDR=YES) ---
    Dim wbPath As String, spec As String, rng As String, lastCell As String, srcRef As String
    wbPath = ThisWorkbook.FullName
    spec = ExcelSpecFromPath(wbPath)
    rng = ws.UsedRange.Address(False, False)
    lastCell = Split(rng, ":")(UBound(Split(rng, ":")))
    srcRef = "[" & spec & ";HDR=YES;IMEX=0;Database=" & wbPath & "].[" & ws.Name & "$A1:" & lastCell & "]"

    ' --- SET et WHERE dynamiques (on n’écrit que si non vide côté feuille) ---
    Dim sets As String, whereNZ As String
    If hasRisk Then
        sets = sets & IIf(Len(sets) > 0, ", ", "") & " f.risk_cmt = x.[" & RiskHdr & "]"
        whereNZ = whereNZ & IIf(Len(whereNZ) > 0, " OR ", "") & _
                  " (x.[" & RiskHdr & "] Is Not Null AND Len(Trim(x.[" & RiskHdr & "] & ''))>0) "
    End If
    If hasFront Then
        sets = sets & IIf(Len(sets) > 0, ", ", "") & " f.front_cmt = x.[" & FrontHdr & "]"
        whereNZ = whereNZ & IIf(Len(whereNZ) > 0, " OR ", "") & _
                  " (x.[" & FrontHdr & "] Is Not Null AND Len(Trim(x.[" & FrontHdr & "] & ''))>0) "
    End If
    If Len(whereNZ) = 0 Then Exit Sub

    ' --- 1) FLUX : UPDATE ... JOIN Excel ---
    Dim sql As String
    sql = _
      "UPDATE " & T_FLUX & " AS f " & _
      "INNER JOIN " & srcRef & " AS x " & _
      "ON f.Booking = UCase(Trim(x.[" & BookingHdr & "])) " & _
      "AND f.[NO DOSSIER CREDIT] = Trim(x.[" & NDCHdr & "]) " & _
      "SET " & sets & _
      " WHERE " & whereNZ & ";"
    cn.Execute sql, , 128

    ' --- 2) ARCHIVE : selon ArchiveMode ---
    Dim setsArc As String: setsArc = Replace(sets, " f.", " a.") ' même SETs mais alias 'a' (archive)
    Dim sqlArc As String

    If UCase$(ArchiveMode) = "ALL" Then
        ' Met à jour TOUTES les lignes d’Archive qui matchent la clé
        sqlArc = _
          "UPDATE " & T_ARC & " AS a " & _
          "INNER JOIN " & srcRef & " AS x " & _
          "ON a.Booking = UCase(Trim(x.[" & BookingHdr & "])) " & _
          "AND a.[NO DOSSIER CREDIT] = Trim(x.[" & NDCHdr & "]) " & _
          "SET " & setsArc & _
          " WHERE " & whereNZ & ";"

    Else
        ' Par défaut: ne met à jour QUE la DERNIÈRE ligne d’Archive par (Booking, NDC)
        ' last = Max(ID) par clé
        sqlArc = _
          "UPDATE ((" & T_ARC & " AS a " & _
          "INNER JOIN (SELECT Booking, [NO DOSSIER CREDIT], Max(ID) AS MaxID FROM " & T_ARC & " GROUP BY Booking, [NO DOSSIER CREDIT]) AS last " & _
          "ON a.Booking=last.Booking AND a.[NO DOSSIER CREDIT]=last.[NO DOSSIER CREDIT] AND a.ID=last.MaxID) " & _
          "INNER JOIN " & srcRef & " AS x " & _
          "ON a.Booking = UCase(Trim(x.[" & BookingHdr & "])) AND a.[NO DOSSIER CREDIT] = Trim(x.[" & NDCHdr & "])) " & _
          "SET " & setsArc & _
          " WHERE " & whereNZ & ";"
    End If

    cn.Execute sqlArc, , 128
End Sub

' ---------- Petits helpers réutilisables ----------

Private Function ExcelSpecFromPath(ByVal wbPath As String) As String
    Dim ext As String: ext = LCase$(Mid$(wbPath, InStrRev(wbPath, ".") + 1))
    Select Case ext
        Case "xlsx", "xlsm": ExcelSpecFromPath = "Excel 12.0 Xml"
        Case "xlsb":         ExcelSpecFromPath = "Excel 12.0"
        Case "xls":          ExcelSpecFromPath = "Excel 8.0"
        Case Else:           ExcelSpecFromPath = "Excel 12.0 Xml"
    End Select
End Function

Private Function FindHeader(ByVal ws As Worksheet, ByVal hdr As String) As Long
    Dim c As Range
    For Each c In ws.Rows(1).Cells
        If Trim$(UCase$(c.Value & "")) = Trim$(UCase$(hdr)) Then FindHeader = c.Column: Exit Function
        If Len(c.Value & "") = 0 Then Exit For
    Next c
End Function

'--- si tu ne l’as pas déjà (voir messages précédents) ---
Private Function ColumnExists(ByVal cn As ADODB.Connection, ByVal tableName As String, ByVal colName As String) As Boolean
    On Error GoTo fin
    Dim rs As Object
    Set rs = cn.OpenSchema(4, Array(Empty, Empty, tableName, colName)) ' adSchemaColumns=4
    ColumnExists = Not (rs Is Nothing Or rs.EOF)
    If Not rs Is Nothing Then rs.Close
    Set rs = Nothing
    Exit Function
fin:
    ColumnExists = False
End Function

Private Sub AddColumnIfMissing(ByVal cn As ADODB.Connection, ByVal tableName As String, ByVal colName As String, ByVal ddlType As String)
    If Not ColumnExists(cn, tableName, colName) Then
        cn.Execute "ALTER TABLE " & tableName & " ADD COLUMN [" & colName & "] " & ddlType, , 128
    End If
End Sub

Public Sub EnsureCommentColumns(ByVal cn As ADODB.Connection)
    AddColumnIfMissing cn, T_FLUX,  "risk_cmt",  "LONGTEXT"
    AddColumnIfMissing cn, T_FLUX,  "front_cmt", "LONGTEXT"
    AddColumnIfMissing cn, T_FLUX,  "close_cmt", "LONGTEXT"
    AddColumnIfMissing cn, T_ARC,   "risk_cmt",  "LONGTEXT"
    AddColumnIfMissing cn, T_ARC,   "front_cmt", "LONGTEXT"
    AddColumnIfMissing cn, T_ARC,   "close_cmt", "LONGTEXT"
End Sub


Notes importantes


Clé utilisée pour joindre : UCase(Trim(Booking)) et Trim(N° dossier) — aligne avec ta normalisation de T_Today/T_Flux.


Pas d’écrasement par des vides : condition WHERE côté feuille impose Is Not Null AND Len(Trim(...))>0.


Archive :


"Latest" = met à jour uniquement l’épisode le plus récent par (Booking, NDC) (via Max(ID)).


"All" = met à jour toutes les lignes pour cette clé (utile si tu veux répliquer une correction sur l’historique).




Performances : 2 requêtes SQL set-based (Flux + Archive). Même avec des milliers de lignes interface, c’est quasi instantané.


Si tu veux aussi pousser close_cmt depuis l’interface, dupliques le même pattern avec un 3ᵉ champ (CloseHdr), en l’ajoutant dans sets/whereNZ.

# Code Corrigé

Option Explicit

'==========================
'  PARAMÈTRES / CONSTANTES
'==========================
Private Const DB_NAME As String = "Lombards2.accdb"
Private Const T_FLUX   As String = "T_Flux"
Private Const T_ARC    As String = "T_Archive"

' En-têtes attendus sur la feuille Interface
Private Const COL_BOOKING   As String = "Booking"
Private Const COL_DOSSIER   As String = "NO DOSSIER CREDIT"
Private Const COL_RISK_CMT  As String = "risk_cmt"          ' alias FR acceptés
Private Const COL_FRONT_CMT As String = "front_cmt"         ' alias FR acceptés

' ADO const
Private Const adCmdText As Long = 1
Private Const adExecuteNoRecords As Long = 128
Private Const adVarWChar As Long = 202
Private Const adLongVarWChar As Long = 203

'==========================
'   PROCÉDURE PUBLIQUE
'==========================
' wsInterface : feuille qui contient Booking / NDC / risk_cmt / front_cmt
' target: "FLUX" | "ARCHIVE" | "BOTH"
Public Sub UpdateRiskFrontCommentsFromSheet( _
    ByVal wsInterface As Worksheet, _
    Optional ByVal target As String = "BOTH" _
)
    Dim dbPath As String
    dbPath = ThisWorkbook.Path & Application.PathSeparator & DB_NAME

    Dim cn As Object: Set cn = GetConn(dbPath)
    Call EnsureCommentColumns(cn)  'ajoute risk_cmt/front_cmt/close_cmt si absent

    '--- Map colonnes de la feuille ---
    Dim colMap As Object: Set colMap = CreateObject("Scripting.Dictionary")
    MapCol colMap, wsInterface, COL_BOOKING
    MapCol colMap, wsInterface, COL_DOSSIER
    MapCol colMap, wsInterface, COL_RISK_CMT, "Commentaire Risque"
    MapCol colMap, wsInterface, COL_FRONT_CMT, "Commentaire Front"

    '--- Lignes utiles ---
    Dim lastRow As Long: lastRow = wsInterface.Cells(wsInterface.Rows.Count, colMap(COL_BOOKING)).End(xlUp).Row
    If lastRow < 2 Then GoTo QUIT

    Dim n As Long: n = lastRow - 1

    '--- Lecture en bloc (ultra rapide) ---
    Dim arrBk As Variant, arrNdc As Variant, arrRisk As Variant, arrFront As Variant
    arrBk = wsInterface.Range(wsInterface.Cells(2, colMap(COL_BOOKING)), wsInterface.Cells(lastRow, colMap(COL_BOOKING))).Value2
    arrNdc = wsInterface.Range(wsInterface.Cells(2, colMap(COL_DOSSIER)), wsInterface.Cells(lastRow, colMap(COL_DOSSIER))).Value2
    arrRisk = wsInterface.Range(wsInterface.Cells(2, colMap(COL_RISK_CMT)), wsInterface.Cells(lastRow, colMap(COL_RISK_CMT))).Value2
    arrFront = wsInterface.Range(wsInterface.Cells(2, colMap(COL_FRONT_CMT)), wsInterface.Cells(lastRow, colMap(COL_FRONT_CMT))).Value2

    '--- Snapshots clefs existantes ---
    Dim fluxKeys As Object: Set fluxKeys = BuildFluxKeyDict(cn)          'key -> True
    Dim arcLastIds As Object: Set arcLastIds = BuildArchiveLatestIdDict(cn) 'key -> Max(ID)

    '--- Prépare les commandes paramétrées (plus rapide, sans Nz) ---
    Dim cmdFluxRisk As Object, cmdFluxFront As Object
    Dim cmdArcRisk As Object, cmdArcFront As Object

    If UCase$(target) = "FLUX" Or UCase$(target) = "BOTH" Then
        Set cmdFluxRisk = CreateObject("ADODB.Command")
        With cmdFluxRisk
            .ActiveConnection = cn
            .CommandType = adCmdText
            .CommandText = "UPDATE " & T_FLUX & " SET risk_cmt=? WHERE Booking=? AND [NO DOSSIER CREDIT]=?"
            .Parameters.Append .CreateParameter(, adLongVarWChar, 1) ' risk_cmt
            .Parameters.Append .CreateParameter(, adVarWChar, 1, 20) ' Booking
            .Parameters.Append .CreateParameter(, adVarWChar, 1, 50) ' NDC
            .Prepared = True
        End With

        Set cmdFluxFront = CreateObject("ADODB.Command")
        With cmdFluxFront
            .ActiveConnection = cn
            .CommandType = adCmdText
            .CommandText = "UPDATE " & T_FLUX & " SET front_cmt=? WHERE Booking=? AND [NO DOSSIER CREDIT]=?"
            .Parameters.Append .CreateParameter(, adLongVarWChar, 1) ' front_cmt
            .Parameters.Append .CreateParameter(, adVarWChar, 1, 20) ' Booking
            .Parameters.Append .CreateParameter(, adVarWChar, 1, 50) ' NDC
            .Prepared = True
        End With
    End If

    If UCase$(target) = "ARCHIVE" Or UCase$(target) = "BOTH" Then
        Set cmdArcRisk = CreateObject("ADODB.Command")
        With cmdArcRisk
            .ActiveConnection = cn
            .CommandType = adCmdText
            .CommandText = "UPDATE " & T_ARC & " SET risk_cmt=? WHERE ID=?"
            .Parameters.Append .CreateParameter(, adLongVarWChar, 1) ' risk_cmt
            .Parameters.Append .CreateParameter(, 3, 1)             ' ID (adInteger=3)
            .Prepared = True
        End With

        Set cmdArcFront = CreateObject("ADODB.Command")
        With cmdArcFront
            .ActiveConnection = cn
            .CommandType = adCmdText
            .CommandText = "UPDATE " & T_ARC & " SET front_cmt=? WHERE ID=?"
            .Parameters.Append .CreateParameter(, adLongVarWChar, 1) ' front_cmt
            .Parameters.Append .CreateParameter(, 3, 1)             ' ID
            .Prepared = True
        End With
    End If

    '--- Transaction (sécurité + perfs) ---
    cn.BeginTrans

    Dim i As Long, k As String, bk As String, ndc As String
    Dim risk As String, front As String, latestId As Long

    For i = 1 To n
        bk = Trim$(UCase$(CStr(arrBk(i, 1) & "")))
        ndc = Trim$(CStr(arrNdc(i, 1) & ""))
        If Len(bk) = 0 Or Len(ndc) = 0 Then GoTo NextI

        k = bk & "||" & ndc
        risk = Trim$(CStr(arrRisk(i, 1) & ""))
        front = Trim$(CStr(arrFront(i, 1) & ""))

        ' --- FLUX ---
        If (UCase$(target) = "FLUX" Or UCase$(target) = "BOTH") And fluxKeys.Exists(k) Then
            If Len(risk) > 0 Then
                cmdFluxRisk.Parameters(0).Value = risk
                cmdFluxRisk.Parameters(1).Value = bk
                cmdFluxRisk.Parameters(2).Value = ndc
                cmdFluxRisk.Execute , , adExecuteNoRecords
            End If
            If Len(front) > 0 Then
                cmdFluxFront.Parameters(0).Value = front
                cmdFluxFront.Parameters(1).Value = bk
                cmdFluxFront.Parameters(2).Value = ndc
                cmdFluxFront.Execute , , adExecuteNoRecords
            End If
        End If

        ' --- ARCHIVE (dernière ligne par clé) ---
        If (UCase$(target) = "ARCHIVE" Or UCase$(target) = "BOTH") And arcLastIds.Exists(k) Then
            latestId = CLng(arcLastIds(k))
            If latestId > 0 Then
                If Len(risk) > 0 Then
                    cmdArcRisk.Parameters(0).Value = risk
                    cmdArcRisk.Parameters(1).Value = latestId
                    cmdArcRisk.Execute , , adExecuteNoRecords
                End If
                If Len(front) > 0 Then
                    cmdArcFront.Parameters(0).Value = front
                    cmdArcFront.Parameters(1).Value = latestId
                    cmdArcFront.Execute , , adExecuteNoRecords
                End If
            End If
        End If

NextI:
    Next i

    cn.CommitTrans

QUIT:
    On Error Resume Next
    If Not cn Is Nothing Then If cn.State = 1 Then cn.Close
    Set cn = Nothing
End Sub

'==========================
'   SNAPSHOTS CIBLES
'==========================
' Dictionnaire des clés présentes en FLUX (key="BOOK||NDC")
Private Function BuildFluxKeyDict(ByVal cn As Object) As Object
    Dim D As Object: Set D = CreateObject("Scripting.Dictionary")
    D.CompareMode = 1
    Dim rs As Object: Set rs = cn.Execute("SELECT Booking, [NO DOSSIER CREDIT] FROM " & T_FLUX)
    Dim v As Variant: v = rs.GetRows()
    rs.Close: Set rs = Nothing
    On Error Resume Next
    Dim i As Long
    For i = 0 To UBound(v, 2)
        D(Trim$(UCase$(CStr(v(0, i) & ""))) & "||" & Trim$(CStr(v(1, i) & ""))) = True
    Next i
    On Error GoTo 0
    Set BuildFluxKeyDict = D
End Function

' Dictionnaire clé -> dernier ID d'archive (MAX(ID) par clé)
Private Function BuildArchiveLatestIdDict(ByVal cn As Object) As Object
    Dim D As Object: Set D = CreateObject("Scripting.Dictionary")
    D.CompareMode = 1
    Dim sql As String
    sql = "SELECT Booking, [NO DOSSIER CREDIT], MAX(ID) AS LastID " & _
          "FROM " & T_ARC & " GROUP BY Booking, [NO DOSSIER CREDIT]"
    Dim rs As Object: Set rs = cn.Execute(sql)
    Dim v As Variant: v = rs.GetRows()
    rs.Close: Set rs = Nothing
    On Error Resume Next
    Dim i As Long
    For i = 0 To UBound(v, 2)
        D(Trim$(UCase$(CStr(v(0, i) & ""))) & "||" & Trim$(CStr(v(1, i) & ""))) = CLng(v(2, i))
    Next i
    On Error GoTo 0
    Set BuildArchiveLatestIdDict = D
End Function

'==========================
'   SCHEMA SAFEGUARD
'==========================
' Ajoute risk_cmt / front_cmt / close_cmt aux tables si absents
Private Sub EnsureCommentColumns(ByVal cn As Object)
    On Error Resume Next

    ' FLUX
    If Not ColumnExists(cn, T_FLUX, "risk_cmt") Then _
        cn.Execute "ALTER TABLE " & T_FLUX & " ADD COLUMN risk_cmt LONGTEXT", , adExecuteNoRecords
    If Not ColumnExists(cn, T_FLUX, "front_cmt") Then _
        cn.Execute "ALTER TABLE " & T_FLUX & " ADD COLUMN front_cmt LONGTEXT", , adExecuteNoRecords
    If Not ColumnExists(cn, T_FLUX, "close_cmt") Then _
        cn.Execute "ALTER TABLE " & T_FLUX & " ADD COLUMN close_cmt LONGTEXT", , adExecuteNoRecords

    ' ARCHIVE
    If Not ColumnExists(cn, T_ARC, "risk_cmt") Then _
        cn.Execute "ALTER TABLE " & T_ARC & " ADD COLUMN risk_cmt LONGTEXT", , adExecuteNoRecords
    If Not ColumnExists(cn, T_ARC, "front_cmt") Then _
        cn.Execute "ALTER TABLE " & T_ARC & " ADD COLUMN front_cmt LONGTEXT", , adExecuteNoRecords
    If Not ColumnExists(cn, T_ARC, "close_cmt") Then _
        cn.Execute "ALTER TABLE " & T_ARC & " ADD COLUMN close_cmt LONGTEXT", , adExecuteNoRecords

    On Error GoTo 0
End Sub

Private Function ColumnExists(ByVal cn As Object, ByVal tableName As String, ByVal colName As String) As Boolean
    On Error GoTo fin
    Dim rs As Object
    Set rs = cn.OpenSchema(4) 'adSchemaColumns
    Do While Not rs.EOF
        If StrComp(rs.Fields("TABLE_NAME").Value & "", tableName, vbTextCompare) = 0 _
           And StrComp(rs.Fields("COLUMN_NAME").Value & "", colName, vbTextCompare) = 0 Then
            ColumnExists = True
            Exit Do
        End If
        rs.MoveNext
    Loop
    rs.Close: Set rs = Nothing
fin:
End Function

'==========================
'   HELPERS GÉNÉRIQUES
'==========================
Private Function GetConn(ByVal dbPath As String) As Object
    Dim cn As Object: Set cn = CreateObject("ADODB.Connection")
    On Error Resume Next
    cn.Open "Provider=Microsoft.ACE.OLEDB.16.0;Data Source=" & dbPath & ";Persist Security Info=False;"
    If cn.State = 0 Then cn.Open "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & dbPath & ";Persist Security Info=False;"
    On Error GoTo 0
    Set GetConn = cn
End Function

Private Sub MapCol(ByVal dict As Object, ByVal ws As Worksheet, ByVal name1 As String, Optional ByVal name2 As String = "")
    Dim c As Long: c = FindHeader(ws, name1)
    If c = 0 And Len(name2) > 0 Then c = FindHeader(ws, name2)
    If c = 0 Then Err.Raise vbObjectError + 10, , "Colonne introuvable : " & name1 & IIf(Len(name2) > 0, " (alt : " & name2 & ")", "")
    dict(name1) = c
End Sub

Private Function FindHeader(ByVal ws As Worksheet, ByVal hdr As String) As Long
    Dim c As Range
    For Each c In ws.Rows(1).Cells
        If Trim$(UCase$(c.Value & "")) = Trim$(UCase$(hdr)) Then FindHeader = c.Column: Exit Function
        If Len(c.Value & "") = 0 Then Exit For
    Next c
End Function
