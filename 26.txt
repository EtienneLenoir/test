Function IdentifyDateColumns(ByVal dataArray As Variant) As Boolean()
    Dim i As Long, j As Long
    Dim validDates As Long
    Dim totalRows As Long, totalCols As Long
    Dim dateColumns() As Boolean
    
    ' Initialiser le nombre de lignes et de colonnes
    totalRows = UBound(dataArray, 1)
    totalCols = UBound(dataArray, 2)
    
    ' Dimensionner le tableau pour stocker les résultats pour chaque colonne
    ReDim dateColumns(1 To totalCols)
    
    ' Parcourir chaque colonne
    For j = 1 To totalCols
        validDates = 0
        
        ' Parcourir les données de la colonne spécifiée
        For i = 1 To totalRows
            ' Vérifier si chaque cellule contient une date valide
            If IsDate(dataArray(i, j)) Then
                validDates = validDates + 1
            End If
        Next i
        
        ' Si un pourcentage significatif des cellules est des dates, on considère la colonne comme une colonne de dates
        If validDates / totalRows > 0.8 Then
            dateColumns(j) = True
        Else
            dateColumns(j) = False
        End If
    Next j
    
    ' Retourner le tableau contenant les résultats pour chaque colonne
    IdentifyDateColumns = dateColumns
End Function



Function ContainsString(ByVal searchRange As Range, ByVal searchString As String) As Boolean
    Dim cell As Range
    Dim found As Range
    
    ' Use the Find method for a quick search
    Set found = searchRange.Find(What:=searchString, LookIn:=xlValues, LookAt:=xlPart, MatchCase:=False)
    
    ' Check if the string was found
    If Not found Is Nothing Then
        ContainsString = True
    Else
        ContainsString = False
    End If
End Function

Function ContainsStringFast(ByVal searchRange As Range, ByVal searchString As String) As Boolean
    Dim dataArray As Variant
    Dim i As Long, j As Long
    
    ' Charger la plage dans un tableau en mémoire
    dataArray = searchRange.Value
    
    ' Parcourir le tableau pour rechercher la chaîne
    For i = LBound(dataArray, 1) To UBound(dataArray, 1)
        For j = LBound(dataArray, 2) To UBound(dataArray, 2)
            If InStr(1, dataArray(i, j), searchString, vbTextCompare) > 0 Then
                ContainsStringFast = True
                Exit Function
            End If
        Next j
    Next i
    
    ' Si la chaîne n'est pas trouvée, retourner False
    ContainsStringFast = False
End Function


Sub Calculate6MVolatilityOptimized()
    Dim ws As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim volFormulas() As String
    Dim numFormulas As Long

    ' Set the active sheet or a specific sheet
    Set ws = ThisWorkbook.Sheets("Sheet1") ' Replace "Sheet1" with your actual sheet name

    ' Find the last filled row in column J (where daily returns are)
    lastRow = ws.Cells(ws.Rows.Count, "J").End(xlUp).Row

    ' Calculate how many formulas we need to store
    numFormulas = lastRow - 120 - 2
    
    ' Resize the array to hold all the formulas
    ReDim volFormulas(1 To numFormulas, 1 To 1)

    ' Populate the array with the volatility formulas
    For i = 1 To numFormulas
        volFormulas(i, 1) = "=STDEV(J" & (i + 2) & ":J" & (i + 121) & ") * SQRT(260)"
    Next i

    ' Write all the formulas to the correct range in one go
    ws.Range("L122").Resize(numFormulas, 1).Formula = volFormulas

    ' Optional: Message to confirm the end of the calculation
    MsgBox "6-month rolling volatility calculation is complete", vbInformation
End Sub

#


Sub CalculateReturnsAndVolatilityOptimized(rendementType As String, volatilitePeriode As Integer)
    Dim ws As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim returnFormulas() As String
    Dim volFormulas() As String
    Dim numReturns As Long
    Dim numVols As Long
    Dim startRow As Long
    Dim endRow As Long

    ' Set the active sheet or a specific sheet
    Set ws = ThisWorkbook.Sheets("Sheet1") ' Replace "Sheet1" with your actual sheet name

    ' Find the last filled row in column I (where daily prices are)
    lastRow = ws.Cells(ws.Rows.Count, "I").End(xlUp).Row

    ' Calculate how many returns we need to store
    numReturns = lastRow - 2

    ' Resize the array to hold all the return formulas
    ReDim returnFormulas(1 To numReturns, 1 To 1)

    ' Populate the array with the return formulas based on selected type
    If rendementType = "arithmetique" Then
        For i = 1 To numReturns
            returnFormulas(i, 1) = "=(I" & (i + 2) & "/I" & (i + 1) & ") - 1"
        Next i
    ElseIf rendementType = "logarithmique" Then
        For i = 1 To numReturns
            returnFormulas(i, 1) = "=LOG(I" & (i + 2) & "/I" & (i + 1) & ")"
        Next i
    Else
        MsgBox "Type de rendement non valide. Veuillez choisir 'arithmetique' ou 'logarithmique'.", vbExclamation
        Exit Sub
    End If

    ' Write all the return formulas to the correct range in one go
    ws.Range("J3").Resize(numReturns, 1).Formula = returnFormulas

    ' Calculate how many volatility formulas we need to store based on the selected period
    startRow = 3
    endRow = lastRow - volatilitePeriode

    If endRow <= startRow Then
        MsgBox "Période de volatilité trop longue pour les données disponibles.", vbExclamation
        Exit Sub
    End If

    numVols = endRow - startRow + 1

    ' Resize the array to hold all the volatility formulas
    ReDim volFormulas(1 To numVols, 1 To 1)

    ' Populate the array with the volatility formulas
    For i = 1 To numVols
        volFormulas(i, 1) = "=STDEV(J" & (i + 2) & ":J" & (i + 1 + volatilitePeriode) & ") * SQRT(260)"
    Next i

    ' Write all the volatility formulas to the correct range in one go
    ws.Range("L" & (startRow + volatilitePeriode)).Resize(numVols, 1).Formula = volFormulas

    ' Optional: Message to confirm the end of the calculation
    MsgBox "Calcul des rendements et de la volatilité glissante est terminé", vbInformation
End Sub


Sub ExempleUtilisation()
    Call CalculateReturnsAndVolatilityOptimized("logarithmique", 260)
End Sub

Sub ExempleUtilisation2()
    Call CalculateReturnsAndVolatilityOptimized("arithmetique", 520)
End Sub

###

Sub AnalyzeDateRangeFromArray(ByVal dataArray As Variant, ByVal dateColIndex As Long)
    Dim startDate As Date
    Dim endDate As Date
    Dim frequency As String
    Dim daysCount As Long
    Dim monthsCount As Long
    Dim yearsCount As Long
    Dim i As Long
    Dim dateDiff As Long
    Dim sampleDiff As Long
    Dim totalRows As Long

    ' Initialize variables
    totalRows = UBound(dataArray, 1)
    startDate = dataArray(1, dateColIndex)
    endDate = dataArray(totalRows, dateColIndex)
    
    ' Calculate the difference between consecutive dates for the first few rows
    dateDiff = 0
    For i = 1 To Application.Min(10, totalRows - 1)
        sampleDiff = DateDiff("d", dataArray(i, dateColIndex), dataArray(i + 1, dateColIndex))
        dateDiff = dateDiff + sampleDiff
    Next i
    dateDiff = dateDiff / i

    ' Determine frequency based on average date difference
    Select Case dateDiff
        Case Is < 2
            frequency = "Daily"
            daysCount = DateDiff("d", startDate, endDate) + 1
            yearsCount = daysCount / 365.25
        Case Is < 15
            frequency = "Monthly"
            monthsCount = DateDiff("m", startDate, endDate) + 1
            yearsCount = monthsCount / 12
        Case Else
            frequency = "Quarterly"
            monthsCount = DateDiff("q", startDate, endDate) + 1
            yearsCount = monthsCount / 4
    End Select

    ' Output the results
    Debug.Print "Start Date: " & startDate
    Debug.Print "End Date: " & endDate
    Debug.Print "Frequency: " & frequency
    
    If frequency = "Daily" Then
        Debug.Print "Number of Days: " & daysCount
        Debug.Print "Number of Years: " & yearsCount
    Else
        Debug.Print "Number of Months: " & monthsCount
        Debug.Print "Number of Years: " & yearsCount
    End If
End Sub
